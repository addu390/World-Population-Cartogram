{"mappings":"qJAAIA,EAAUC,KAAKC,GAAK,EACpBC,EAAS,CAAC,EAAGH,EAAS,EAAIA,EAAS,EAAIA,EAAS,EAAIA,EAAS,EAAIA,GAErE,SAASI,EAAOC,GACd,OAAOA,EAAE,GAGX,SAASC,EAAOD,GACd,OAAOA,EAAE,aCJH,SAAUE,GAEjB,SAASC,EAAUC,EAAGC,GACpB,OAAOD,EAAIC,GAAI,EAAKD,EAAIC,EAAI,EAAID,GAAKC,EAAI,EAAIC,IAG/C,SAASC,EAASC,GAEhB,OADuB,IAAnBA,EAAQC,SAAcD,EAAUE,EAAoBF,IACjD,CACLG,KAAM,SAASP,EAAGQ,EAAGC,EAAIC,GAGvB,IAFU,MAAND,IAAYA,EAAK,GACX,MAANC,IAAYA,EAAKV,EAAEK,QAChBI,EAAKC,GAAI,CACd,IAAIC,EAAMF,EAAKC,IAAO,EAClBN,EAAQJ,EAAEW,GAAMH,GAAK,EAAGC,EAAKE,EAAM,EAClCD,EAAKC,EAEZ,OAAOF,GAETG,MAAO,SAASZ,EAAGQ,EAAGC,EAAIC,GAGxB,IAFU,MAAND,IAAYA,EAAK,GACX,MAANC,IAAYA,EAAKV,EAAEK,QAChBI,EAAKC,GAAI,CACd,IAAIC,EAAMF,EAAKC,IAAO,EAClBN,EAAQJ,EAAEW,GAAMH,GAAK,EAAGE,EAAKC,EAC5BF,EAAKE,EAAM,EAElB,OAAOF,IAKb,SAASH,EAAoBO,GAC3B,OAAO,SAASjB,EAAGY,GACjB,OAAOT,EAAUc,EAAEjB,GAAIY,IAM3B,SAASM,EAAMC,GAQb,IAPA,IACIC,EAGAC,EACAC,EALAC,EAAIJ,EAAOV,OAEXe,GAAI,EACJC,EAAI,IAICD,EAAID,GAAGE,GAAKN,EAAOK,GAAGf,OAG/B,IAFAY,EAAS,IAAIK,MAAMD,KAEVF,GAAK,GAGZ,IADAH,GADAE,EAAQH,EAAOI,IACLd,SACDW,GAAK,GACZC,IAASI,GAAKH,EAAMF,GAIxB,OAAOC,EAGT,SAASM,EAAIL,EAAOL,GAClB,IAEIb,EAFAwB,EAAI,EACJL,EAAID,EAAMb,OAEVe,GAAI,EAER,GAAS,MAALP,EACF,OAASO,EAAID,IAAOnB,GAAKkB,EAAME,MAAII,GAAKxB,QAIxC,OAASoB,EAAID,IAAOnB,GAAKa,EAAEK,EAAME,GAAIA,EAAGF,MAAQM,GAAKxB,GAGvD,OAAOwB,EAUT,SAASC,IACP,OAAO,IAAIC,EAGb,SAASA,IACPC,KAAKC,QArDezB,EAASJ,GAwD/B2B,EAAMG,UAAY,CAChBC,YAAaJ,EACbE,MAAO,WACLD,KAAKH,EACLG,KAAKI,EAAI,GAEXC,IAAK,SAASC,GACZC,EAAIC,EAAMF,EAAGN,KAAKI,GAClBG,EAAIP,KAAMQ,EAAKX,EAAGG,KAAKH,GACnBG,KAAKH,EAAGG,KAAKI,GAAKI,EAAKJ,EACtBJ,KAAKH,EAAIW,EAAKJ,GAErBK,QAAS,WACP,OAAOT,KAAKH,IAIhB,IAAIW,EAAO,IAAIT,EAEf,SAASQ,EAAIG,EAAOrC,EAAGC,GACrB,IAAIO,EAAI6B,EAAMb,EAAIxB,EAAIC,EAClBqC,EAAK9B,EAAIR,EACTuC,EAAK/B,EAAI8B,EACbD,EAAMN,EAAK/B,EAAIuC,GAAOtC,EAAIqC,GAG5B,IAAIE,EAAU,KACVC,EAAKjD,KAAKC,GACViD,EAASD,EAAK,EACdE,EAAYF,EAAK,EACjBG,EAAW,EAALH,EAENI,EAAU,IAAMJ,EAChBK,EAAUL,EAAK,IAEfM,EAAMvD,KAAKuD,IACXC,EAAOxD,KAAKwD,KACZC,EAAQzD,KAAKyD,MACbC,EAAM1D,KAAK0D,IACXC,EAAM3D,KAAK2D,IACXC,EAAO5D,KAAK6D,MAAQ,SAAS7C,GAAK,OAAOA,EAAI,EAAI,EAAIA,EAAI,GAAI,EAAK,GAClE8C,EAAO9D,KAAK8D,KAChB,SAASC,EAAK/C,GACZ,OAAOA,EAAI,EAAI,EAAIA,GAAI,EAAKiC,EAAKjD,KAAK+D,KAAK/C,GAG7C,SAASgD,EAAKhD,GACZ,OAAOA,EAAI,EAAIkC,EAASlC,GAAI,GAAMkC,EAASlD,KAAKgE,KAAKhD,GAGvD,SAASiD,KAET,SAASC,EAAeC,EAAUC,GAC5BD,GAAYE,EAAmBC,eAAeH,EAASI,OACzDF,EAAmBF,EAASI,MAAMJ,EAAUC,GAIhD,IAAII,EAAmB,CACrBC,QAAS,SAASC,EAAQN,GACxBF,EAAeQ,EAAOP,SAAUC,IAElCO,kBAAmB,SAASD,EAAQN,GAElC,IADA,IAAIQ,EAAWF,EAAOE,SAAUhD,GAAI,EAAID,EAAIiD,EAAS/D,SAC5Ce,EAAID,GAAGuC,EAAeU,EAAShD,GAAGuC,SAAUC,KAIrDC,EAAqB,CACvBQ,OAAQ,SAASH,EAAQN,GACvBA,EAAOU,UAETC,MAAO,SAASL,EAAQN,GACtBM,EAASA,EAAOM,YAChBZ,EAAOa,MAAMP,EAAO,GAAIA,EAAO,GAAIA,EAAO,KAE5CQ,WAAY,SAASR,EAAQN,GAE3B,IADA,IAAIY,EAAcN,EAAOM,YAAapD,GAAI,EAAID,EAAIqD,EAAYnE,SACrDe,EAAID,GAAG+C,EAASM,EAAYpD,GAAIwC,EAAOa,MAAMP,EAAO,GAAIA,EAAO,GAAIA,EAAO,KAErFS,WAAY,SAAST,EAAQN,GAC3BgB,EAAWV,EAAOM,YAAaZ,EAAQ,IAEzCiB,gBAAiB,SAASX,EAAQN,GAEhC,IADA,IAAIY,EAAcN,EAAOM,YAAapD,GAAI,EAAID,EAAIqD,EAAYnE,SACrDe,EAAID,GAAGyD,EAAWJ,EAAYpD,GAAIwC,EAAQ,IAErDkB,QAAS,SAASZ,EAAQN,GACxBmB,EAAcb,EAAOM,YAAaZ,IAEpCoB,aAAc,SAASd,EAAQN,GAE7B,IADA,IAAIY,EAAcN,EAAOM,YAAapD,GAAI,EAAID,EAAIqD,EAAYnE,SACrDe,EAAID,GAAG4D,EAAcP,EAAYpD,GAAIwC,IAEhDqB,mBAAoB,SAASf,EAAQN,GAEnC,IADA,IAAIsB,EAAahB,EAAOgB,WAAY9D,GAAI,EAAID,EAAI+D,EAAW7E,SAClDe,EAAID,GAAGuC,EAAewB,EAAW9D,GAAIwC,KAIlD,SAASgB,EAAWJ,EAAaZ,EAAQuB,GACvC,IAA6CC,EAAzChE,GAAI,EAAID,EAAIqD,EAAYnE,OAAS8E,EAErC,IADAvB,EAAOyB,cACEjE,EAAID,GAAGiE,EAAaZ,EAAYpD,GAAIwC,EAAOa,MAAMW,EAAW,GAAIA,EAAW,GAAIA,EAAW,IACnGxB,EAAO0B,UAGT,SAASP,EAAcP,EAAaZ,GAClC,IAAIxC,GAAI,EAAID,EAAIqD,EAAYnE,OAE5B,IADAuD,EAAO2B,iBACEnE,EAAID,GAAGyD,EAAWJ,EAAYpD,GAAIwC,EAAQ,GACnDA,EAAO4B,aAGT,SAASC,EAAUvB,EAAQN,GACrBM,GAAUF,EAAiBF,eAAeI,EAAOH,MACnDC,EAAiBE,EAAOH,MAAMG,EAAQN,GAEtCF,EAAeQ,EAAQN,GAmE3B,SAAS8B,EAAUC,GACjB,MAAO,CAAC1C,EAAM0C,EAAU,GAAIA,EAAU,IAAKnC,EAAKmC,EAAU,KAG5D,SAASC,EAAUC,GACjB,IAAIC,EAASD,EAAU,GAAIE,EAAMF,EAAU,GAAIG,EAAS9C,EAAI6C,GAC5D,MAAO,CAACC,EAAS9C,EAAI4C,GAASE,EAAS7C,EAAI2C,GAAS3C,EAAI4C,IAG1D,SAASE,EAAajG,EAAGC,GACvB,OAAOD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAG9C,SAASiG,EAAelG,EAAGC,GACzB,MAAO,CAACD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAID,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAID,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,IAIvF,SAASkG,EAAoBnG,EAAGC,GAC9BD,EAAE,IAAMC,EAAE,GAAID,EAAE,IAAMC,EAAE,GAAID,EAAE,IAAMC,EAAE,GAGxC,SAASmG,EAAeC,EAAQC,GAC9B,MAAO,CAACD,EAAO,GAAKC,EAAGD,EAAO,GAAKC,EAAGD,EAAO,GAAKC,GAIpD,SAASC,EAA0B3G,GACjC,IAAI4G,EAAIlD,EAAK1D,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAClDA,EAAE,IAAM4G,EAAG5G,EAAE,IAAM4G,EAAG5G,EAAE,IAAM4G,EA+PhC,SAASC,EAAQzG,EAAGC,GAElB,SAASyG,EAAQlG,EAAGyB,GAClB,OAAOzB,EAAIR,EAAEQ,EAAGyB,GAAIhC,EAAEO,EAAE,GAAIA,EAAE,IAOhC,OAJIR,EAAE2G,QAAU1G,EAAE0G,SAAQD,EAAQC,OAAS,SAASnG,EAAGyB,GACrD,OAAOzB,EAAIP,EAAE0G,OAAOnG,EAAGyB,KAASjC,EAAE2G,OAAOnG,EAAE,GAAIA,EAAE,MAG5CkG,EAGT,SAASE,EAAiBd,EAAQC,GAChC,MAAO,CAACD,EAASrD,EAAKqD,EAASlD,EAAMkD,GAAUrD,EAAKqD,EAASlD,EAAMkD,EAAQC,GAK7E,SAASc,EAAcC,EAAaC,EAAUC,GAC5C,OAAQF,GAAelE,GAAQmE,GAAYC,EAAaP,EAAQQ,EAAeH,GAAcI,EAAiBH,EAAUC,IACpHC,EAAeH,GACdC,GAAYC,EAAaE,EAAiBH,EAAUC,GACrDJ,EAGN,SAASO,EAAsBL,GAC7B,OAAO,SAAShB,EAAQC,GACtB,MAA8B,EAAvBD,GAAUgB,GAAuBrE,EAAKqD,EAASlD,EAAMkD,GAAUrD,EAAKqD,EAASlD,EAAMkD,EAAQC,IAItG,SAASkB,EAAeH,GACtB,IAAIM,EAAWD,EAAsBL,GAErC,OADAM,EAAST,OAASQ,GAAuBL,GAClCM,EAGT,SAASF,EAAiBH,EAAUC,GAClC,IAAIK,EAAcnE,EAAI6D,GAClBO,EAAcnE,EAAI4D,GAClBQ,EAAgBrE,EAAI8D,GACpBQ,EAAgBrE,EAAI6D,GAExB,SAASI,EAAStB,EAAQC,GACxB,IAAIC,EAAS9C,EAAI6C,GACbvF,EAAI0C,EAAI4C,GAAUE,EAClB/D,EAAIkB,EAAI2C,GAAUE,EAClByB,EAAItE,EAAI4C,GACRO,EAAImB,EAAIJ,EAAc7G,EAAI8G,EAC9B,MAAO,CACLrE,EAAMhB,EAAIsF,EAAgBjB,EAAIkB,EAAehH,EAAI6G,EAAcI,EAAIH,GACnE9D,EAAK8C,EAAIiB,EAAgBtF,EAAIuF,IAgBjC,OAZAJ,EAAST,OAAS,SAASb,EAAQC,GACjC,IAAIC,EAAS9C,EAAI6C,GACbvF,EAAI0C,EAAI4C,GAAUE,EAClB/D,EAAIkB,EAAI2C,GAAUE,EAClByB,EAAItE,EAAI4C,GACRO,EAAImB,EAAIF,EAAgBtF,EAAIuF,EAChC,MAAO,CACLvE,EAAMhB,EAAIsF,EAAgBE,EAAID,EAAehH,EAAI6G,EAAcf,EAAIgB,GACnE9D,EAAK8C,EAAIe,EAAc7G,EAAI8G,KAIxBF,EAIP,SAAOM,EAAa9D,EAAQ+D,EAAQC,EAAOC,EAAWC,EAAIC,GAC1D,GAAKH,EAAL,CACA,IAAII,EAAY9E,EAAIyE,GAChBM,EAAY9E,EAAIwE,GAChBO,EAAOL,EAAYD,EACb,MAANE,GACFA,EAAKH,EAASE,EAAYjF,EAC1BmF,EAAKJ,EAASO,EAAO,IAErBJ,EAAKK,EAAaH,EAAWF,GAC7BC,EAAKI,EAAaH,EAAWD,IACzBF,EAAY,EAAIC,EAAKC,EAAKD,EAAKC,KAAID,GAAMD,EAAYjF,IAE3D,IAAK,IAAI6B,EAAO1C,EAAI+F,EAAID,EAAY,EAAI9F,EAAIgG,EAAKhG,EAAIgG,EAAIhG,GAAKmG,EAC5DzD,EAAQiB,EAAU,CAACsC,GAAYC,EAAY/E,EAAInB,IAAKkG,EAAY9E,EAAIpB,KACpE6B,EAAOa,MAAMA,EAAM,GAAIA,EAAM,KAKjC,SAAS0D,EAAaH,EAAWvD,IAC/BA,EAAQmB,EAAUnB,IAAc,IAAMuD,EACtCzB,EAA0B9B,GAC1B,IAAIkD,EAASpE,GAAMkB,EAAM,IACzB,SAAUA,EAAM,GAAK,GAAKkD,EAASA,GAAU/E,EAAMJ,GAAWI,EAGhE,SAASwF,IACP,IACIC,EADAC,EAAQ,GAEZ,MAAO,CACL7D,MAAO,SAASjE,EAAGyB,GACjBoG,EAAKE,KAAK,CAAC/H,EAAGyB,KAEhBoD,UAAW,WACTiD,EAAMC,KAAKF,EAAO,KAEpB/C,QAAS7B,EACT+E,OAAQ,WACFF,EAAMjI,OAAS,GAAGiI,EAAMC,KAAKD,EAAMG,MAAMC,OAAOJ,EAAMK,WAE5DC,OAAQ,WACN,IAAIA,EAASN,EAGb,OAFAA,EAAQ,GACRD,EAAO,KACAO,IAKb,SAASC,EAAS7I,EAAGC,EAAG6I,EAAIC,EAAIC,EAAIC,GAClC,IAQIC,EARAC,EAAKnJ,EAAE,GACPoJ,EAAKpJ,EAAE,GAGP8H,EAAK,EACLC,EAAK,EACLsB,EAJKpJ,EAAE,GAIGkJ,EACVG,EAJKrJ,EAAE,GAIGmJ,EAId,GADAF,EAAIJ,EAAKK,EACJE,KAAMH,EAAI,GAAf,CAEA,GADAA,GAAKG,EACDA,EAAK,EAAG,CACV,GAAIH,EAAIpB,EAAI,OACRoB,EAAInB,IAAIA,EAAKmB,QACZ,GAAIG,EAAK,EAAG,CACjB,GAAIH,EAAInB,EAAI,OACRmB,EAAIpB,IAAIA,EAAKoB,GAInB,GADAA,EAAIF,EAAKG,EACJE,KAAMH,EAAI,GAAf,CAEA,GADAA,GAAKG,EACDA,EAAK,EAAG,CACV,GAAIH,EAAInB,EAAI,OACRmB,EAAIpB,IAAIA,EAAKoB,QACZ,GAAIG,EAAK,EAAG,CACjB,GAAIH,EAAIpB,EAAI,OACRoB,EAAInB,IAAIA,EAAKmB,GAInB,GADAA,EAAIH,EAAKK,EACJE,KAAMJ,EAAI,GAAf,CAEA,GADAA,GAAKI,EACDA,EAAK,EAAG,CACV,GAAIJ,EAAIpB,EAAI,OACRoB,EAAInB,IAAIA,EAAKmB,QACZ,GAAII,EAAK,EAAG,CACjB,GAAIJ,EAAInB,EAAI,OACRmB,EAAIpB,IAAIA,EAAKoB,GAInB,GADAA,EAAID,EAAKG,EACJE,KAAMJ,EAAI,GAAf,CAEA,GADAA,GAAKI,EACDA,EAAK,EAAG,CACV,GAAIJ,EAAInB,EAAI,OACRmB,EAAIpB,IAAIA,EAAKoB,QACZ,GAAII,EAAK,EAAG,CACjB,GAAIJ,EAAIpB,EAAI,OACRoB,EAAInB,IAAIA,EAAKmB,GAKnB,OAFIpB,EAAK,IAAG9H,EAAE,GAAKmJ,EAAKrB,EAAKuB,EAAIrJ,EAAE,GAAKoJ,EAAKtB,EAAKwB,GAC9CvB,EAAK,IAAG9H,EAAE,GAAKkJ,EAAKpB,EAAKsB,EAAIpJ,EAAE,GAAKmJ,EAAKrB,EAAKuB,IAC3C,MAGT,SAASC,EAAWvJ,EAAGC,GACrB,OAAO8C,EAAI/C,EAAE,GAAKC,EAAE,IAAMuC,GAAWO,EAAI/C,EAAE,GAAKC,EAAE,IAAMuC,EAG1D,SAASgH,EAAa/E,EAAOgF,EAAQC,EAAOC,GAC1ChI,KAAKnB,EAAIiE,EACT9C,KAAK8F,EAAIgC,EACT9H,KAAKiI,EAAIF,EACT/H,KAAKkI,EAAIF,EACThI,KAAKmI,GAAI,EACTnI,KAAKR,EAAIQ,KAAKoI,EAAI,KAMpB,SAASC,EAAYC,EAAUC,EAAqBC,EAAaC,EAAaxG,GAC5E,IAEIxC,EACAiJ,EAHAC,EAAU,GACVC,EAAO,GAwBX,GApBAN,EAASO,SAAQ,SAASC,GACxB,MAAKtJ,EAAIsJ,EAAQpK,OAAS,IAAM,GAAhC,CACA,IAAIc,EAAqCX,EAAlCkK,EAAKD,EAAQ,GAAIE,EAAKF,EAAQtJ,GAKrC,GAAIoI,EAAWmB,EAAIC,GAAnB,CAEE,IADA/G,EAAOyB,YACFjE,EAAI,EAAGA,EAAID,IAAKC,EAAGwC,EAAOa,OAAOiG,EAAKD,EAAQrJ,IAAI,GAAIsJ,EAAG,IAC9D9G,EAAO0B,eAITgF,EAAQ/B,KAAK/H,EAAI,IAAIgJ,EAAakB,EAAID,EAAS,MAAM,IACrDF,EAAKhC,KAAK/H,EAAEoJ,EAAI,IAAIJ,EAAakB,EAAI,KAAMlK,GAAG,IAC9C8J,EAAQ/B,KAAK/H,EAAI,IAAIgJ,EAAamB,EAAIF,EAAS,MAAM,IACrDF,EAAKhC,KAAK/H,EAAEoJ,EAAI,IAAIJ,EAAamB,EAAI,KAAMnK,GAAG,QAG3C8J,EAAQjK,OAAb,CAMA,IAJAkK,EAAKK,KAAKV,GACVW,GAAKP,GACLO,GAAKN,GAEAnJ,EAAI,EAAGiJ,EAAIE,EAAKlK,OAAQe,EAAIiJ,IAAKjJ,EACpCmJ,EAAKnJ,GAAGyI,EAAIM,GAAeA,EAO7B,IAJA,IACIV,EACAhF,EAFAqG,EAAQR,EAAQ,KAIV,CAIR,IAFA,IAAIS,EAAUD,EACVE,GAAY,EACTD,EAAQjB,OAAQiB,EAAUA,EAAQ5J,KAAO2J,EAAO,OACvDrB,EAASsB,EAAQtD,EACjB7D,EAAOyB,YACP,EAAG,CAED,GADA0F,EAAQjB,EAAIiB,EAAQnB,EAAEE,GAAI,EACtBiB,EAAQlB,EAAG,CACb,GAAImB,EACF,IAAK5J,EAAI,EAAGiJ,EAAIZ,EAAOpJ,OAAQe,EAAIiJ,IAAKjJ,EAAGwC,EAAOa,OAAOA,EAAQgF,EAAOrI,IAAI,GAAIqD,EAAM,SAEtF2F,EAAYW,EAAQvK,EAAGuK,EAAQ5J,EAAEX,EAAG,EAAGoD,GAEzCmH,EAAUA,EAAQ5J,MACb,CACL,GAAI6J,EAEF,IADAvB,EAASsB,EAAQhB,EAAEtC,EACdrG,EAAIqI,EAAOpJ,OAAS,EAAGe,GAAK,IAAKA,EAAGwC,EAAOa,OAAOA,EAAQgF,EAAOrI,IAAI,GAAIqD,EAAM,SAEpF2F,EAAYW,EAAQvK,EAAGuK,EAAQhB,EAAEvJ,GAAG,EAAIoD,GAE1CmH,EAAUA,EAAQhB,EAGpBN,GADAsB,EAAUA,EAAQnB,GACDnC,EACjBuD,GAAaA,SACLD,EAAQjB,GAClBlG,EAAO0B,YAIX,SAASuF,GAAK3J,GACZ,GAAMC,EAAID,EAAMb,OAAhB,CAKA,IAJA,IAAIc,EAGAlB,EAFAmB,EAAI,EACJpB,EAAIkB,EAAM,KAELE,EAAID,GACXnB,EAAEmB,EAAIlB,EAAIiB,EAAME,GAChBnB,EAAE8J,EAAI/J,EACNA,EAAIC,EAEND,EAAEmB,EAAIlB,EAAIiB,EAAM,GAChBjB,EAAE8J,EAAI/J,GAtnBUyB,IAEJA,IAqGCA,IAqQfmF,EAAiBD,OAASC,EA6Q1B,IAAIqE,GAAU,IACVC,IAAWD,GAIf,SAASE,GAAWrC,EAAIC,EAAIC,EAAIC,GAE9B,SAASmC,EAAQ5K,EAAGyB,GAClB,OAAO6G,GAAMtI,GAAKA,GAAKwI,GAAMD,GAAM9G,GAAKA,GAAKgH,EAG/C,SAASmB,EAAYiB,EAAMC,EAAIzD,EAAWjE,GACxC,IAAI5D,EAAI,EAAGuL,EAAK,EAChB,GAAY,MAARF,IACIrL,EAAIwL,EAAOH,EAAMxD,OAAiB0D,EAAKC,EAAOF,EAAIzD,KACnD4D,EAAaJ,EAAMC,GAAM,EAAIzD,EAAY,EAC9C,GAAGjE,EAAOa,MAAY,IAANzE,GAAiB,IAANA,EAAU8I,EAAKE,EAAIhJ,EAAI,EAAIiJ,EAAKF,UACnD/I,GAAKA,EAAI6H,EAAY,GAAK,KAAO0D,QAEzC3H,EAAOa,MAAM6G,EAAG,GAAIA,EAAG,IAI3B,SAASE,EAAOzB,EAAGlC,GACjB,OAAO9E,EAAIgH,EAAE,GAAKjB,GAAMtG,EAAUqF,EAAY,EAAI,EAAI,EAChD9E,EAAIgH,EAAE,GAAKf,GAAMxG,EAAUqF,EAAY,EAAI,EAAI,EAC/C9E,EAAIgH,EAAE,GAAKhB,GAAMvG,EAAUqF,EAAY,EAAI,EAAI,EAC/CA,EAAY,EAAI,EAAI,EAG5B,SAASqC,EAAoBlK,EAAGC,GAC9B,OAAOwL,EAAazL,EAAEQ,EAAGP,EAAEO,GAG7B,SAASiL,EAAazL,EAAGC,GACvB,IAAIyL,EAAKF,EAAOxL,EAAG,GACf2L,EAAKH,EAAOvL,EAAG,GACnB,OAAOyL,IAAOC,EAAKD,EAAKC,EACX,IAAPD,EAAWzL,EAAE,GAAKD,EAAE,GACb,IAAP0L,EAAW1L,EAAE,GAAKC,EAAE,GACb,IAAPyL,EAAW1L,EAAE,GAAKC,EAAE,GACpBA,EAAE,GAAKD,EAAE,GAGjB,OAAO,SAAS4D,GACd,IAEIqG,EACA2B,EACAC,EACAC,EAAKC,EAAKC,EACVC,EAAIC,EAAIC,EACRC,EACAC,EARAC,EAAe1I,EACf2I,EAAenE,IASfoE,EAAa,CACf/H,MAAOgI,EACPpH,UAAWA,EACXC,QAASA,EACTC,aAAcA,EACdC,WAAYA,GAGd,SAASiH,EAAMjM,EAAGyB,GACZmJ,EAAQ5K,EAAGyB,IAAIqK,EAAa7H,MAAMjE,EAAGyB,GAG3C,SAASyK,IAGP,IAFA,IAAIC,EAAU,EAELvL,EAAI,EAAGD,EAAIyK,EAAQvL,OAAQe,EAAID,IAAKC,EAC3C,IAAK,IAAgEwL,EAAIrB,EAAhEsB,EAAOjB,EAAQxK,GAAIC,EAAI,EAAGL,EAAI6L,EAAKxM,OAAQoE,EAAQoI,EAAK,GAAYC,EAAKrI,EAAM,GAAIsI,EAAKtI,EAAM,GAAIpD,EAAIL,IAAKK,EAClHuL,EAAKE,EAAIvB,EAAKwB,EAAqBD,GAAjBrI,EAAQoI,EAAKxL,IAAe,GAAI0L,EAAKtI,EAAM,GACzD8G,GAAMtC,EAAU8D,EAAK9D,IAAO6D,EAAKF,IAAO3D,EAAKsC,IAAOwB,EAAKxB,IAAOzC,EAAK8D,MAAOD,EACrEI,GAAM9D,IAAO6D,EAAKF,IAAO3D,EAAKsC,IAAOwB,EAAKxB,IAAOzC,EAAK8D,MAAOD,EAI5E,OAAOA,EAIT,SAASpH,IACP+G,EAAeC,EAActC,EAAW,GAAI2B,EAAU,GAAIS,GAAQ,EAGpE,SAAS7G,IACP,IAAI2E,EAAcuC,IACdM,EAAcX,GAASlC,EACvB8C,GAAWhD,EAAWnJ,EAAMmJ,IAAW5J,QACvC2M,GAAeC,KACjBrJ,EAAO2B,eACHyH,IACFpJ,EAAOyB,YACP+E,EAAY,KAAM,KAAM,EAAGxG,GAC3BA,EAAO0B,WAEL2H,GACFjD,EAAYC,EAAUC,EAAqBC,EAAaC,EAAaxG,GAEvEA,EAAO4B,cAET8G,EAAe1I,EAAQqG,EAAW2B,EAAUC,EAAO,KAGrD,SAASxG,IACPmH,EAAW/H,MAAQyI,EACftB,GAASA,EAAQrD,KAAKsD,EAAO,IACjCO,GAAQ,EACRD,GAAK,EACLF,EAAKC,EAAKhM,IAMZ,SAASoF,IACH2E,IACFiD,EAAUpB,EAAKC,GACXC,GAAOG,GAAII,EAAa/D,SAC5ByB,EAAS1B,KAAKgE,EAAa3D,WAE7B4D,EAAW/H,MAAQgI,EACfN,GAAIG,EAAahH,UAGvB,SAAS4H,EAAU1M,EAAGyB,GACpB,IAAI6H,EAAIsB,EAAQ5K,EAAGyB,GAEnB,GADI2J,GAASC,EAAKtD,KAAK,CAAC/H,EAAGyB,IACvBmK,EACFN,EAAMtL,EAAGuL,EAAM9J,EAAG+J,EAAMlC,EACxBsC,GAAQ,EACJtC,IACFwC,EAAajH,YACbiH,EAAa7H,MAAMjE,EAAGyB,SAGxB,GAAI6H,GAAKqC,EAAIG,EAAa7H,MAAMjE,EAAGyB,OAC9B,CACH,IAAIjC,EAAI,CAACiM,EAAKzM,KAAK2N,IAAIjC,GAAS1L,KAAK4N,IAAInC,GAASgB,IAAMC,EAAK1M,KAAK2N,IAAIjC,GAAS1L,KAAK4N,IAAInC,GAASiB,KAC7FjM,EAAI,CAACO,EAAIhB,KAAK2N,IAAIjC,GAAS1L,KAAK4N,IAAInC,GAASzK,IAAKyB,EAAIzC,KAAK2N,IAAIjC,GAAS1L,KAAK4N,IAAInC,GAAShJ,KAC1F4G,EAAS7I,EAAGC,EAAG6I,EAAIC,EAAIC,EAAIC,IACxBkD,IACHG,EAAajH,YACbiH,EAAa7H,MAAMzE,EAAE,GAAIA,EAAE,KAE7BsM,EAAa7H,MAAMxE,EAAE,GAAIA,EAAE,IACtB6J,GAAGwC,EAAahH,UACrB+G,GAAQ,GACCvC,IACTwC,EAAajH,YACbiH,EAAa7H,MAAMjE,EAAGyB,GACtBoK,GAAQ,GAIdJ,EAAKzL,EAAG0L,EAAKjK,EAAGkK,EAAKrC,EAGvB,OAAO0C,GAIX,IAAIa,GAAQ5L,IAEZ,SAAS6L,GAAgB1B,EAASnH,GAChC,IAAIqB,EAASrB,EAAM,GACfsB,EAAMtB,EAAM,GACZ8I,EAAS,CAACpK,EAAI2C,IAAU5C,EAAI4C,GAAS,GACrC0H,EAAQ,EACRb,EAAU,EAEdU,GAAMzL,QAEN,IAAK,IAAIR,EAAI,EAAGD,EAAIyK,EAAQvL,OAAQe,EAAID,IAAKC,EAC3C,GAAMJ,GAAK6L,EAAOjB,EAAQxK,IAAIf,OAS9B,IARA,IAAIwM,EACA7L,EACAyM,EAASZ,EAAK7L,EAAI,GAClB0M,EAAUD,EAAO,GACjBE,EAAOF,EAAO,GAAK,EAAI9K,EACvBiL,EAAUzK,EAAIwK,GACdE,EAAU3K,EAAIyK,GAETtM,EAAI,EAAGA,EAAIL,IAAKK,EAAGqM,EAAUI,EAASF,EAAUG,EAASF,EAAUG,EAASP,EAAShB,EAAQ,CACpG,IAAIA,EAASI,EAAKxL,GACdyM,EAAUrB,EAAO,GACjBwB,EAAOxB,EAAO,GAAK,EAAI9J,EACvBoL,EAAU5K,EAAI8K,GACdD,EAAU9K,EAAI+K,GACdrG,EAAQkG,EAAUJ,EAClBrK,EAAOuE,GAAS,EAAI,GAAI,EACxBsG,EAAW7K,EAAOuE,EAClBuG,EAAeD,EAAWzL,EAC1B6D,EAAIsH,EAAUG,EAOlB,GALAV,GAAMrL,IAAIiB,EAAMqD,EAAIjD,EAAOF,EAAI+K,GAAWL,EAAUG,EAAU1H,EAAIpD,EAAIgL,KACtEV,GAASW,EAAevG,EAAQvE,EAAOT,EAAMgF,EAIzCuG,EAAeT,GAAW5H,EAASgI,GAAWhI,EAAQ,CACxD,IAAIsI,EAAMlI,EAAeN,EAAU6H,GAAS7H,EAAU6G,IACtDlG,EAA0B6H,GAC1B,IAAIC,EAAenI,EAAeqH,EAAQa,GAC1C7H,EAA0B8H,GAC1B,IAAIC,GAAUH,EAAevG,GAAS,GAAI,EAAK,GAAKpE,EAAK6K,EAAa,KAClEtI,EAAMuI,GAAUvI,IAAQuI,IAAWF,EAAI,IAAMA,EAAI,OACnDzB,GAAWwB,EAAevG,GAAS,EAAI,GAAI,IAiBnD,OAAQ4F,GAAShL,GAAWgL,EAAQhL,GAAW6K,IAAS7K,GAAsB,EAAVmK,EA6CtE,SAAS4B,GAAW/N,GAClB,OAAOA,EA3COiB,IA8ChB,IAEI+M,GACAC,GACAC,GACAC,GALAC,GAAYnN,IACZoN,GAAgBpN,IAKhBqN,GAAe,CACjBrK,MAAOhB,EACP4B,UAAW5B,EACX6B,QAAS7B,EACT8B,aAAc,WACZuJ,GAAazJ,UAAY0J,GACzBD,GAAaxJ,QAAU0J,IAEzBxJ,WAAY,WACVsJ,GAAazJ,UAAYyJ,GAAaxJ,QAAUwJ,GAAarK,MAAQhB,EACrEmL,GAAU5M,IAAIe,EAAI8L,KAClBA,GAAcjN,SAEhBgH,OAAQ,WACN,IAAIqG,EAAOL,GAAY,EAEvB,OADAA,GAAUhN,QACHqN,IAIX,SAASF,KACPD,GAAarK,MAAQyK,GAGvB,SAASA,GAAiB1O,EAAGyB,GAC3B6M,GAAarK,MAAQ0K,GACrBX,GAAME,GAAOlO,EAAGiO,GAAME,GAAO1M,EAG/B,SAASkN,GAAY3O,EAAGyB,GACtB4M,GAAc7M,IAAI2M,GAAOnO,EAAIkO,GAAOzM,GACpCyM,GAAOlO,EAAGmO,GAAO1M,EAGnB,SAAS+M,KACPG,GAAYX,GAAKC,IAGnB,IAAIW,GAAOC,EAAAA,EACPC,GAAOF,GACPG,IAAMH,GACNI,GAAKD,GACLE,GAAiB,CACnBhL,MAAOiL,GACPrK,UAAW5B,EACX6B,QAAS7B,EACT8B,aAAc9B,EACd+B,WAAY/B,EACZmF,OAAQ,WACN,IAAI+G,EAAS,CAAC,CAACP,GAAME,IAAO,CAACC,GAAIC,KAEjC,OADAD,GAAKC,KAAOF,GAAOF,GAAOC,EAAAA,GACnBM,IAIX,SAASD,GAAclP,EAAGyB,GACpBzB,EAAI4O,KAAMA,GAAO5O,GACjBA,EAAI+O,KAAIA,GAAK/O,GACbyB,EAAIqN,KAAMA,GAAOrN,GACjBA,EAAIuN,KAAIA,GAAKvN,GAGnB,IASI2N,GACAC,GACAC,GACAC,GAZAC,GAAO,EACPC,GAAO,EACPC,GAAO,EACPC,GAAO,EACPC,GAAO,EACPC,GAAO,EACPC,GAAO,EACPC,GAAO,EACPC,GAAO,EAKPC,GAAmB,CACrBhM,MAAOiM,GACPrL,UAAWsL,GACXrL,QAASsL,GACTrL,aAAc,WACZkL,GAAiBpL,UAAYwL,GAC7BJ,GAAiBnL,QAAUwL,IAE7BtL,WAAY,WACViL,GAAiBhM,MAAQiM,GACzBD,GAAiBpL,UAAYsL,GAC7BF,GAAiBnL,QAAUsL,IAE7BhI,OAAQ,WACN,IAAImI,EAAWP,GAAO,CAACF,GAAOE,GAAMD,GAAOC,IACrCH,GAAO,CAACF,GAAOE,GAAMD,GAAOC,IAC5BH,GAAO,CAACF,GAAOE,GAAMD,GAAOC,IAC5B,CAAChQ,IAAKA,KAIZ,OAHA8P,GAAOC,GAAOC,GACdC,GAAOC,GAAOC,GACdC,GAAOC,GAAOC,GAAO,EACdO,IAIX,SAASL,GAAgBlQ,EAAGyB,GAC1B+N,IAAQxP,EACRyP,IAAQhO,IACNiO,GAGJ,SAASS,KACPF,GAAiBhM,MAAQuM,GAG3B,SAASA,GAAuBxQ,EAAGyB,GACjCwO,GAAiBhM,MAAQwM,GACzBP,GAAgBZ,GAAOtP,EAAGuP,GAAO9N,GAGnC,SAASgP,GAAkBzQ,EAAGyB,GAC5B,IAAIoH,EAAK7I,EAAIsP,GAAMxG,EAAKrH,EAAI8N,GAAMtI,EAAInE,EAAK+F,EAAKA,EAAKC,EAAKA,GAC1D6G,IAAQ1I,GAAKqI,GAAOtP,GAAK,EACzB4P,IAAQ3I,GAAKsI,GAAO9N,GAAK,EACzBoO,IAAQ5I,EACRiJ,GAAgBZ,GAAOtP,EAAGuP,GAAO9N,GAGnC,SAAS2O,KACPH,GAAiBhM,MAAQiM,GAG3B,SAASG,KACPJ,GAAiBhM,MAAQyM,GAG3B,SAASJ,KACPK,GAAkBvB,GAAOC,IAG3B,SAASqB,GAAuB1Q,EAAGyB,GACjCwO,GAAiBhM,MAAQ0M,GACzBT,GAAgBd,GAAQE,GAAOtP,EAAGqP,GAAQE,GAAO9N,GAGnD,SAASkP,GAAkB3Q,EAAGyB,GAC5B,IAAIoH,EAAK7I,EAAIsP,GACTxG,EAAKrH,EAAI8N,GACTtI,EAAInE,EAAK+F,EAAKA,EAAKC,EAAKA,GAE5B6G,IAAQ1I,GAAKqI,GAAOtP,GAAK,EACzB4P,IAAQ3I,GAAKsI,GAAO9N,GAAK,EACzBoO,IAAQ5I,EAGR6I,KADA7I,EAAIsI,GAAOvP,EAAIsP,GAAO7N,IACT6N,GAAOtP,GACpB+P,IAAQ9I,GAAKsI,GAAO9N,GACpBuO,IAAY,EAAJ/I,EACRiJ,GAAgBZ,GAAOtP,EAAGuP,GAAO9N,GAGnC,SAASmP,GAAYC,GACnB1P,KAAK2P,SAAWD,EAGlBD,GAAYvP,UAAY,CACtB0P,QAAS,IACTC,YAAa,SAASC,GACpB,OAAO9P,KAAK4P,QAAUE,EAAG9P,MAE3B4D,aAAc,WACZ5D,KAAK+P,MAAQ,GAEflM,WAAY,WACV7D,KAAK+P,MAAQxR,KAEfmF,UAAW,WACT1D,KAAKgQ,OAAS,GAEhBrM,QAAS,WACY,IAAf3D,KAAK+P,OAAa/P,KAAK2P,SAASM,YACpCjQ,KAAKgQ,OAASzR,KAEhBuE,MAAO,SAASjE,EAAGyB,GACjB,OAAQN,KAAKgQ,QACX,KAAK,EACHhQ,KAAK2P,SAASO,OAAOrR,EAAGyB,GACxBN,KAAKgQ,OAAS,EACd,MAEF,KAAK,EACHhQ,KAAK2P,SAASQ,OAAOtR,EAAGyB,GACxB,MAEF,QACEN,KAAK2P,SAASO,OAAOrR,EAAImB,KAAK4P,QAAStP,GACvCN,KAAK2P,SAASlD,IAAI5N,EAAGyB,EAAGN,KAAK4P,QAAS,EAAG3O,KAK/CgG,OAAQnF,GAGV,IACIsO,GACAC,GACAC,GACAC,GACAC,GALAC,GAAc3Q,IAMd4Q,GAAiB,CACnB5N,MAAOhB,EACP4B,UAAW,WACTgN,GAAe5N,MAAQ6N,IAEzBhN,QAAS,WACHyM,IAAYQ,GAAcP,GAAOC,IACrCI,GAAe5N,MAAQhB,GAEzB8B,aAAc,WACZwM,IAAa,GAEfvM,WAAY,WACVuM,GAAa,MAEfnJ,OAAQ,WACN,IAAIvI,GAAU+R,GAEd,OADAA,GAAYxQ,QACLvB,IAIX,SAASiS,GAAmB9R,EAAGyB,GAC7BoQ,GAAe5N,MAAQ8N,GACvBP,GAAQE,GAAO1R,EAAGyR,GAAQE,GAAOlQ,EAGnC,SAASsQ,GAAc/R,EAAGyB,GACxBiQ,IAAQ1R,EAAG2R,IAAQlQ,EACnBmQ,GAAYpQ,IAAIsB,EAAK4O,GAAOA,GAAOC,GAAOA,KAC1CD,GAAO1R,EAAG2R,GAAOlQ,EAGnB,SAASuQ,KACP7Q,KAAK8Q,QAAU,GA+CjB,SAASC,GAAS/K,GAChB,MAAO,MAAQA,EACT,IAAMA,EAAS,IAAMA,EAAS,aAAc,EAAKA,EACjD,IAAMA,EAAS,IAAMA,EAAS,YAAc,EAAIA,EAChD,IAGR,SAASgL,GAAQC,EAAYvB,GAC3B,IACIwB,EACAC,EAFAtB,EAAc,IAIlB,SAASuB,EAAK7O,GAKZ,OAJIA,IACyB,mBAAhBsN,GAA4BsB,EAActB,aAAaA,EAAYwB,MAAMrR,KAAMsR,YAC1FxN,EAAUvB,EAAQ2O,EAAiBC,KAE9BA,EAAclK,SAwCvB,OArCAmK,EAAK9D,KAAO,SAAS/K,GAEnB,OADAuB,EAAUvB,EAAQ2O,EAAiB/D,KAC5BA,GAAalG,UAGtBmK,EAAKG,QAAU,SAAShP,GAEtB,OADAuB,EAAUvB,EAAQ2O,EAAiBR,KAC5BA,GAAezJ,UAGxBmK,EAAKpD,OAAS,SAASzL,GAErB,OADAuB,EAAUvB,EAAQ2O,EAAiBpD,KAC5BA,GAAe7G,UAGxBmK,EAAKhC,SAAW,SAAS7M,GAEvB,OADAuB,EAAUvB,EAAQ2O,EAAiBpC,KAC5BA,GAAiB7H,UAG1BmK,EAAKH,WAAa,SAASnB,GACzB,OAAOwB,UAAU5S,QAAUwS,EAAwB,MAALpB,GAAamB,EAAa,KAAMrE,KAAeqE,EAAanB,GAAG7N,OAAQmP,GAAQH,GAG/HG,EAAK1B,QAAU,SAASI,GACtB,OAAKwB,UAAU5S,QACfyS,EAAqB,MAALrB,GAAaJ,EAAU,KAAM,IAAImB,IAAc,IAAIpB,GAAYC,EAAUI,GAC9D,mBAAhBD,GAA4BsB,EAActB,YAAYA,GAC1DuB,GAHuB1B,GAMhC0B,EAAKvB,YAAc,SAASC,GAC1B,OAAKwB,UAAU5S,QACfmR,EAA2B,mBAANC,EAAmBA,GAAKqB,EAActB,aAAaC,IAAKA,GACtEsB,GAFuBvB,GAKzBuB,EAAKH,WAAWA,GAAYvB,QAAQA,GAG7C,SAAS8B,GAAKC,EAAcC,EAAUjJ,EAAaU,GACjD,OAAO,SAASwI,EAAQC,GACtB,IAKI3H,EACA3B,EACA4C,EAPAxE,EAAOgL,EAASE,GAChBC,EAAeF,EAAO3M,OAAOmE,EAAM,GAAIA,EAAM,IAC7C2I,EAAarL,IACbsL,EAAWL,EAASI,GACpBE,GAAiB,EAKjBpJ,EAAO,CACT9F,MAAOmP,EACPvO,UAAWA,EACXC,QAASA,EACTC,aAAc,WACZgF,EAAK9F,MAAQoP,EACbtJ,EAAKlF,UAAYyO,EACjBvJ,EAAKjF,QAAUyO,EACf9J,EAAW,GACX2B,EAAU,IAEZpG,WAAY,WACV+E,EAAK9F,MAAQmP,EACbrJ,EAAKlF,UAAYA,EACjBkF,EAAKjF,QAAUA,EACf2E,EAAWnJ,EAAMmJ,GACjB,IAAIE,EAAcmD,GAAgB1B,EAAS4H,GACvCvJ,EAAS5J,QACNsT,IAAgBJ,EAAKhO,eAAgBoO,GAAiB,GAC3D3J,EAAYC,EAAU+J,GAAqB7J,EAAaC,EAAamJ,IAC5DpJ,IACJwJ,IAAgBJ,EAAKhO,eAAgBoO,GAAiB,GAC3DJ,EAAKlO,YACL+E,EAAY,KAAM,KAAM,EAAGmJ,GAC3BA,EAAKjO,WAEHqO,IAAgBJ,EAAK/N,aAAcmO,GAAiB,GACxD1J,EAAW2B,EAAU,MAEvBtH,OAAQ,WACNiP,EAAKhO,eACLgO,EAAKlO,YACL+E,EAAY,KAAM,KAAM,EAAGmJ,GAC3BA,EAAKjO,UACLiO,EAAK/N,eAIT,SAASoO,EAAM9N,EAAQC,GACrB,IAAItB,EAAQ6O,EAAOxN,EAAQC,GACvBqN,EAAatN,EAASrB,EAAM,GAAIsB,EAAMtB,EAAM,KAAK8O,EAAK9O,MAAMqB,EAAQC,GAG1E,SAASkO,EAAUnO,EAAQC,GACzB,IAAItB,EAAQ6O,EAAOxN,EAAQC,GAC3BsC,EAAK5D,MAAMA,EAAM,GAAIA,EAAM,IAG7B,SAASY,IACPkF,EAAK9F,MAAQwP,EACb5L,EAAKhD,YAGP,SAASC,IACPiF,EAAK9F,MAAQmP,EACbvL,EAAK/C,UAGP,SAASuO,EAAU/N,EAAQC,GACzB8G,EAAKtE,KAAK,CAACzC,EAAQC,IACnB,IAAItB,EAAQ6O,EAAOxN,EAAQC,GAC3B2N,EAASjP,MAAMA,EAAM,GAAIA,EAAM,IAGjC,SAASqP,IACPJ,EAASrO,YACTwH,EAAO,GAGT,SAASkH,IACPF,EAAUhH,EAAK,GAAG,GAAIA,EAAK,GAAG,IAC9B6G,EAASpO,UAET,IAEIlE,EAA4BJ,EAC5ByJ,EACAhG,EAJA4H,EAAQqH,EAASrH,QACjB6H,EAAeT,EAAW7K,SACvBzH,EAAI+S,EAAa7T,OAQxB,GAJAwM,EAAKpE,MACLmD,EAAQrD,KAAKsE,GACbA,EAAO,KAEF1L,EAGL,GAAY,EAARkL,GAEF,IAAKrL,GADLyJ,EAAUyJ,EAAa,IACN7T,OAAS,GAAK,EAAG,CAGhC,IAFKsT,IAAgBJ,EAAKhO,eAAgBoO,GAAiB,GAC3DJ,EAAKlO,YACAjE,EAAI,EAAGA,EAAIJ,IAAKI,EAAGmS,EAAK9O,OAAOA,EAAQgG,EAAQrJ,IAAI,GAAIqD,EAAM,IAClE8O,EAAKjO,gBAOLnE,EAAI,GAAa,EAARkL,GAAW6H,EAAa3L,KAAK2L,EAAazL,MAAMC,OAAOwL,EAAavL,UAEjFsB,EAAS1B,KAAK2L,EAAaC,OAAOC,KAGpC,OAAO7J,GAIX,SAAS6J,GAAa3J,GACpB,OAAOA,EAAQpK,OAAS,EAK1B,SAAS2T,GAAoBhU,EAAGC,GAC9B,QAASD,EAAIA,EAAEQ,GAAG,GAAK,EAAIR,EAAE,GAAK0C,EAASF,EAAUE,EAAS1C,EAAE,MACvDC,EAAIA,EAAEO,GAAG,GAAK,EAAIP,EAAE,GAAKyC,EAASF,EAAUE,EAASzC,EAAE,IAvOlEuS,GAAW3Q,UAAY,CACrBwS,QAAS3B,GAAS,KAClBlB,YAAa,SAASC,GACpB,OAAO9P,KAAK0S,QAAU3B,GAASjB,GAAI9P,MAErC4D,aAAc,WACZ5D,KAAK+P,MAAQ,GAEflM,WAAY,WACV7D,KAAK+P,MAAQxR,KAEfmF,UAAW,WACT1D,KAAKgQ,OAAS,GAEhBrM,QAAS,WACY,IAAf3D,KAAK+P,OAAa/P,KAAK8Q,QAAQlK,KAAK,KACxC5G,KAAKgQ,OAASzR,KAEhBuE,MAAO,SAASjE,EAAGyB,GACjB,OAAQN,KAAKgQ,QACX,KAAK,EACHhQ,KAAK8Q,QAAQlK,KAAK,IAAK/H,EAAG,IAAKyB,GAC/BN,KAAKgQ,OAAS,EACd,MAEF,KAAK,EACHhQ,KAAK8Q,QAAQlK,KAAK,IAAK/H,EAAG,IAAKyB,GAC/B,MAEF,QACEN,KAAK8Q,QAAQlK,KAAK,IAAK/H,EAAG,IAAKyB,EAAGN,KAAK0S,WAK7CzL,OAAQ,WACN,GAAIjH,KAAK8Q,QAAQpS,OAAQ,CACvB,IAAIuI,EAASjH,KAAK8Q,QAAQ6B,KAAK,IAE/B,OADA3S,KAAK8Q,QAAU,GACR7J,KAmMb,IAAI2L,GAAmBpB,IACrB,WAAa,OAAO,IACpBqB,GACAC,GACA,EAAEhS,GAAKC,IAMT,SAAS8R,GAAqB5Q,GAC5B,IAGIyI,EAHAqB,EAAUxN,IACVyN,EAAOzN,IACPwU,EAAQxU,IAGZ,MAAO,CACLmF,UAAW,WACTzB,EAAOyB,YACPgH,EAAQ,GAEV5H,MAAO,SAASqJ,EAASG,GACvB,IAAI7K,EAAQ0K,EAAU,EAAIrL,GAAMA,EAC5BmF,EAAQ7E,EAAI+K,EAAUJ,GACtB3K,EAAI6E,EAAQnF,GAAMD,GACpBoB,EAAOa,MAAMiJ,EAASC,GAAQA,EAAOM,GAAQ,EAAI,EAAIvL,GAAUA,GAC/DkB,EAAOa,MAAMiQ,EAAO/G,GACpB/J,EAAO0B,UACP1B,EAAOyB,YACPzB,EAAOa,MAAMrB,EAAOuK,GACpB/J,EAAOa,MAAMqJ,EAASH,GACtBtB,EAAQ,GACCqI,IAAUtR,GAASwE,GAASnF,IACjCM,EAAI2K,EAAUgH,GAASlS,IAASkL,GAAWgH,EAAQlS,GACnDO,EAAI+K,EAAU1K,GAASZ,IAASsL,GAAW1K,EAAQZ,GACvDmL,EAAOgH,GAA0BjH,EAASC,EAAMG,EAASG,GACzDrK,EAAOa,MAAMiQ,EAAO/G,GACpB/J,EAAO0B,UACP1B,EAAOyB,YACPzB,EAAOa,MAAMrB,EAAOuK,GACpBtB,EAAQ,GAEVzI,EAAOa,MAAMiJ,EAAUI,EAASH,EAAOM,GACvCyG,EAAQtR,GAEVkC,QAAS,WACP1B,EAAO0B,UACPoI,EAAUC,EAAOzN,KAEnBmM,MAAO,WACL,OAAO,EAAIA,IAKjB,SAASsI,GAA0BjH,EAASC,EAAMG,EAASG,GACzD,IAAIJ,EACAG,EACA4G,EAAoBzR,EAAIuK,EAAUI,GACtC,OAAO/K,EAAI6R,GAAqBpS,EAC1BQ,GAAMG,EAAIwK,IAASK,EAAU9K,EAAI+K,IAAS9K,EAAI2K,GAC1C3K,EAAI8K,IAASJ,EAAU3K,EAAIyK,IAASxK,EAAIuK,KACvCG,EAAUG,EAAU4G,KACxBjH,EAAOM,GAAQ,EAGxB,SAASwG,GAA4BpJ,EAAMC,EAAIzD,EAAWjE,GACxD,IAAImC,EACJ,GAAY,MAARsF,EACFtF,EAAM8B,EAAYnF,EAClBkB,EAAOa,OAAOhC,EAAIsD,GAClBnC,EAAOa,MAAM,EAAGsB,GAChBnC,EAAOa,MAAMhC,EAAIsD,GACjBnC,EAAOa,MAAMhC,EAAI,GACjBmB,EAAOa,MAAMhC,GAAKsD,GAClBnC,EAAOa,MAAM,GAAIsB,GACjBnC,EAAOa,OAAOhC,GAAKsD,GACnBnC,EAAOa,OAAOhC,EAAI,GAClBmB,EAAOa,OAAOhC,EAAIsD,QACb,GAAIhD,EAAIsI,EAAK,GAAKC,EAAG,IAAM9I,EAAS,CACzC,IAAIsD,EAASuF,EAAK,GAAKC,EAAG,GAAK7I,GAAMA,EACrCsD,EAAM8B,EAAY/B,EAAS,EAC3BlC,EAAOa,OAAOqB,EAAQC,GACtBnC,EAAOa,MAAM,EAAGsB,GAChBnC,EAAOa,MAAMqB,EAAQC,QAErBnC,EAAOa,MAAM6G,EAAG,GAAIA,EAAG,IAI3B,SAASuJ,GAAWlN,EAAQmN,GAC1B,IAAIC,EAAK7R,EAAIyE,GACTqN,EAAcD,EAAK,EACnBE,EAAgBlS,EAAIgS,GAAMvS,EAE9B,SAAS4H,EAAYiB,EAAMC,EAAIzD,EAAWjE,GACxC8D,EAAa9D,EAAQ+D,EAAQmN,EAAOjN,EAAWwD,EAAMC,GAGvD,SAAS2B,EAAQnH,EAAQC,GACvB,OAAO7C,EAAI4C,GAAU5C,EAAI6C,GAAOgP,EAOlC,SAAS1B,EAASzP,GAChB,IAAI6J,EACAyH,EACAC,EACAC,EACA/I,EACJ,MAAO,CACLhH,UAAW,WACT+P,EAAMD,GAAK,EACX9I,EAAQ,GAEV5H,MAAO,SAASqB,EAAQC,GACtB,IACI6N,EADAnH,EAAS,CAAC3G,EAAQC,GAElB+D,EAAImD,EAAQnH,EAAQC,GACpBsP,EAAIL,EACAlL,EAAI,EAAIwL,EAAKxP,EAAQC,GACrB+D,EAAIwL,EAAKxP,GAAUA,EAAS,EAAIrD,GAAMA,GAAKsD,GAAO,EAY1D,IAXK0H,IAAW2H,EAAMD,EAAKrL,IAAIlG,EAAOyB,YAGlCyE,IAAMqL,IACRvB,EAAS2B,EAAU9H,EAAQhB,IACvBlD,EAAWkE,EAAQmG,IAAWrK,EAAWkD,EAAQmH,MACnDnH,EAAO,IAAMjK,EACbiK,EAAO,IAAMjK,EACbsH,EAAImD,EAAQR,EAAO,GAAIA,EAAO,MAG9B3C,IAAMqL,EACR9I,EAAQ,EACJvC,GAEFlG,EAAOyB,YACPuO,EAAS2B,EAAU9I,EAAQgB,GAC3B7J,EAAOa,MAAMmP,EAAO,GAAIA,EAAO,MAG/BA,EAAS2B,EAAU9H,EAAQhB,GAC3B7I,EAAOa,MAAMmP,EAAO,GAAIA,EAAO,IAC/BhQ,EAAO0B,WAETmI,EAASmG,OACJ,GAAIqB,GAAiBxH,GAAUuH,EAAclL,EAAG,CACrD,IAAI/H,EAGEsT,EAAIH,KAAQnT,EAAIwT,EAAU9I,EAAQgB,GAAQ,MAC9CpB,EAAQ,EACJ2I,GACFpR,EAAOyB,YACPzB,EAAOa,MAAM1C,EAAE,GAAG,GAAIA,EAAE,GAAG,IAC3B6B,EAAOa,MAAM1C,EAAE,GAAG,GAAIA,EAAE,GAAG,IAC3B6B,EAAO0B,YAEP1B,EAAOa,MAAM1C,EAAE,GAAG,GAAIA,EAAE,GAAG,IAC3B6B,EAAO0B,UACP1B,EAAOyB,YACPzB,EAAOa,MAAM1C,EAAE,GAAG,GAAIA,EAAE,GAAG,OAI7B+H,GAAO2D,GAAWlE,EAAWkE,EAAQhB,IACvC7I,EAAOa,MAAMgI,EAAO,GAAIA,EAAO,IAEjCgB,EAAShB,EAAQ0I,EAAKrL,EAAGoL,EAAKG,GAEhC/P,QAAS,WACH6P,GAAIvR,EAAO0B,UACfmI,EAAS,MAIXpB,MAAO,WACL,OAAOA,GAAU+I,GAAOD,IAAO,IAMrC,SAASI,EAAUvV,EAAGC,EAAGuV,GACvB,IAKInL,EAAK,CAAC,EAAG,EAAG,GACZoL,EAAKvP,EANAN,EAAU5F,GACV4F,EAAU3F,IAMfyV,EAAOzP,EAAawP,EAAIA,GACxBE,EAAOF,EAAG,GACVG,EAAcF,EAAOC,EAAOA,EAGhC,IAAKC,EAAa,OAAQJ,GAAOxV,EAEjC,IAAI6V,EAAMd,EAAKW,EAAOE,EAClBE,GAAMf,EAAKY,EAAOC,EAClBG,EAAQ7P,EAAemE,EAAIoL,GAC3BO,EAAI5P,EAAeiE,EAAIwL,GAE3B1P,EAAoB6P,EADZ5P,EAAeqP,EAAIK,IAI3B,IAAIG,EAAIF,EACJG,EAAIjQ,EAAa+P,EAAGC,GACpBE,EAAKlQ,EAAagQ,EAAGA,GACrBG,EAAKF,EAAIA,EAAIC,GAAMlQ,EAAa+P,EAAGA,GAAK,GAE5C,KAAII,EAAK,GAAT,CAEA,IAAIrU,EAAIuB,EAAK8S,GACTC,EAAIjQ,EAAe6P,IAAKC,EAAInU,GAAKoU,GAIrC,GAHAhQ,EAAoBkQ,EAAGL,GACvBK,EAAI3Q,EAAU2Q,IAETb,EAAK,OAAOa,EAGjB,IAII5O,EAJAiG,EAAU1N,EAAE,GACZ8N,EAAU7N,EAAE,GACZ0N,EAAO3N,EAAE,GACTiO,EAAOhO,EAAE,GAGT6N,EAAUJ,IAASjG,EAAIiG,EAASA,EAAUI,EAASA,EAAUrG,GAEjE,IAAIG,EAAQkG,EAAUJ,EAClB4I,EAAQvT,EAAI6E,EAAQnF,GAAMD,EAM9B,IAHK8T,GAASrI,EAAON,IAAMlG,EAAIkG,EAAMA,EAAOM,EAAMA,EAAOxG,GAF1C6O,GAAS1O,EAAQpF,EAM1B8T,EACE3I,EAAOM,EAAO,EAAIoI,EAAE,IAAMtT,EAAIsT,EAAE,GAAK3I,GAAWlL,EAAUmL,EAAOM,GACjEN,GAAQ0I,EAAE,IAAMA,EAAE,IAAMpI,EAC1BrG,EAAQnF,GAAMiL,GAAW2I,EAAE,IAAMA,EAAE,IAAMvI,GAAU,CACvD,IAAIyI,EAAKnQ,EAAe6P,IAAKC,EAAInU,GAAKoU,GAEtC,OADAhQ,EAAoBoQ,EAAIP,GACjB,CAACK,EAAG3Q,EAAU6Q,MAMzB,SAASjB,EAAKxP,EAAQC,GACpB,IAAImD,EAAI8L,EAAcrN,EAASlF,EAAKkF,EAChC6O,EAAO,EAKX,OAJI1Q,GAAUoD,EAAGsN,GAAQ,EAChB1Q,EAASoD,IAAGsN,GAAQ,GACzBzQ,GAAOmD,EAAGsN,GAAQ,EACbzQ,EAAMmD,IAAGsN,GAAQ,GACnBA,EAGT,OAAOrD,GAAKlG,EAASoG,EAAUjJ,EAAa4K,EAAc,CAAC,GAAIrN,GAAU,EAAElF,EAAIkF,EAASlF,IAG1F,SAASgU,GAAYC,GACnB,OAAO,SAAS9S,GACd,IAAIpC,EAAI,IAAImV,GACZ,IAAK,IAAIC,KAAOF,EAASlV,EAAEoV,GAAOF,EAAQE,GAE1C,OADApV,EAAEoC,OAASA,EACJpC,GAIX,SAASmV,MAYT,SAASE,GAAUjE,EAAYkE,EAAQ5S,GACrC,IAAIgS,EAAIY,EAAO,GAAG,GAAKA,EAAO,GAAG,GAC7BC,EAAID,EAAO,GAAG,GAAKA,EAAO,GAAG,GAC7BvM,EAAOqI,EAAWzH,YAAcyH,EAAWzH,aAE/CyH,EACKoE,MAAM,KACNC,UAAU,CAAC,EAAG,IAEP,MAAR1M,GAAcqI,EAAWzH,WAAW,MAExC1F,EAAUvB,EAAQ0O,EAAWhP,OAAO6L,KAEpC,IAAIxP,EAAIwP,GAAe7G,SACnBtC,EAAI9G,KAAK4N,IAAI8I,GAAKjW,EAAE,GAAG,GAAKA,EAAE,GAAG,IAAK8W,GAAK9W,EAAE,GAAG,GAAKA,EAAE,GAAG,KAC1DO,GAAKsW,EAAO,GAAG,IAAMZ,EAAI5P,GAAKrG,EAAE,GAAG,GAAKA,EAAE,GAAG,KAAO,EACpDgC,GAAK6U,EAAO,GAAG,IAAMC,EAAIzQ,GAAKrG,EAAE,GAAG,GAAKA,EAAE,GAAG,KAAO,EAIxD,OAFY,MAARsK,GAAcqI,EAAWzH,WAAWZ,GAEjCqI,EACFoE,MAAU,IAAJ1Q,GACN2Q,UAAU,CAACzW,EAAGyB,IAGrB,SAASiV,GAAQtE,EAAYuE,EAAMjT,GACjC,OAAO2S,GAAUjE,EAAY,CAAC,CAAC,EAAG,GAAIuE,GAAOjT,GApC/CyS,GAAgB9U,UAAY,CAC1BC,YAAa6U,GACblS,MAAO,SAASjE,EAAGyB,GAAKN,KAAKiC,OAAOa,MAAMjE,EAAGyB,IAC7CqC,OAAQ,WAAa3C,KAAKiC,OAAOU,UACjCe,UAAW,WAAa1D,KAAKiC,OAAOyB,aACpCC,QAAS,WAAa3D,KAAKiC,OAAO0B,WAClCC,aAAc,WAAa5D,KAAKiC,OAAO2B,gBACvCC,WAAY,WAAa7D,KAAKiC,OAAO4B,eAgCvC,IAAI4R,GAAW,GACXC,GAAiBnU,EAAI,GAAKJ,GAG9B,SAASwU,GAASC,EAASC,GACzB,OAAQA,EAASC,GAAWF,EAASC,GAAUE,GAAaH,GAG9D,SAASG,GAAaH,GACpB,OAAOd,GAAY,CACjBhS,MAAO,SAASjE,EAAGyB,GACjBzB,EAAI+W,EAAQ/W,EAAGyB,GACfN,KAAKiC,OAAOa,MAAMjE,EAAE,GAAIA,EAAE,OAKhC,SAASiX,GAAWF,EAASC,GAE3B,SAASG,EAAe7O,EAAIC,EAAI2E,EAASd,EAAIE,EAAIoI,EAAIlM,EAAIC,EAAI6E,EAASvC,EAAIwB,EAAI8I,EAAI+B,EAAOhU,GACvF,IAAIyF,EAAKL,EAAKF,EACVQ,EAAKL,EAAKF,EACV8O,EAAKxO,EAAKA,EAAKC,EAAKA,EACxB,GAAIuO,EAAK,EAAIL,GAAUI,IAAS,CAC9B,IAAI5X,EAAI4M,EAAKrB,EACTtL,EAAI6M,EAAKC,EACTsI,EAAIH,EAAKW,EACT7U,EAAIsC,EAAKtD,EAAIA,EAAIC,EAAIA,EAAIoV,EAAIA,GAC7ByC,EAAOtU,EAAK6R,GAAKrU,GACjB+W,EAAUhV,EAAIA,EAAIsS,GAAK,GAAK7S,GAAWO,EAAI2K,EAAUI,GAAWtL,GAAWkL,EAAUI,GAAW,EAAI7K,EAAMhD,EAAGD,GAC7G+J,EAAIwN,EAAQQ,EAASD,GACrBE,EAAKjO,EAAE,GACPkO,EAAKlO,EAAE,GACPmO,EAAMF,EAAKlP,EACXqP,EAAMF,EAAKlP,EACXqP,EAAK9O,EAAK4O,EAAM7O,EAAK8O,GACrBC,EAAKA,EAAKP,EAAKL,GACZzU,GAAKsG,EAAK6O,EAAM5O,EAAK6O,GAAON,EAAK,IAAO,IACxCjL,EAAKrB,EAAKuB,EAAKC,EAAKmI,EAAKW,EAAKwB,MACnCM,EAAe7O,EAAIC,EAAI2E,EAASd,EAAIE,EAAIoI,EAAI8C,EAAIC,EAAIF,EAAS/X,GAAKgB,EAAGf,GAAKe,EAAGqU,EAAGuC,EAAOhU,GACvFA,EAAOa,MAAMuT,EAAIC,GACjBN,EAAeK,EAAIC,EAAIF,EAAS/X,EAAGC,EAAGoV,EAAGrM,EAAIC,EAAI6E,EAASvC,EAAIwB,EAAI8I,EAAI+B,EAAOhU,KAInF,OAAO,SAASA,GACd,IAAIyU,EAAUC,EAAKC,EAAKC,EAAKC,EAAKC,EAC9BhL,EAAS5E,EAAIC,EAAI6D,EAAIE,EAAIoI,EAEzByD,EAAiB,CACnBlU,MAAOA,EACPY,UAAWA,EACXC,QAASA,EACTC,aAAc,WAAa3B,EAAO2B,eAAgBoT,EAAetT,UAAYyO,GAC7EtO,WAAY,WAAa5B,EAAO4B,aAAcmT,EAAetT,UAAYA,IAG3E,SAASZ,EAAMjE,EAAGyB,GAChBzB,EAAI+W,EAAQ/W,EAAGyB,GACf2B,EAAOa,MAAMjE,EAAE,GAAIA,EAAE,IAGvB,SAAS6E,IACPyD,EAAK5I,IACLyY,EAAelU,MAAQyI,EACvBtJ,EAAOyB,YAGT,SAAS6H,EAAUpH,EAAQC,GACzB,IAAIsP,EAAIzP,EAAU,CAACE,EAAQC,IAAOgE,EAAIwN,EAAQzR,EAAQC,GACtD4R,EAAe7O,EAAIC,EAAI2E,EAASd,EAAIE,EAAIoI,EAAIpM,EAAKiB,EAAE,GAAIhB,EAAKgB,EAAE,GAAI2D,EAAU5H,EAAQ8G,EAAKyI,EAAE,GAAIvI,EAAKuI,EAAE,GAAIH,EAAKG,EAAE,GAAI+B,GAAUxT,GAC/HA,EAAOa,MAAMqE,EAAIC,GAGnB,SAASzD,IACPqT,EAAelU,MAAQA,EACvBb,EAAO0B,UAGT,SAASwO,IACPzO,IACAsT,EAAelU,MAAQmU,EACvBD,EAAerT,QAAUyO,EAG3B,SAAS6E,EAAU9S,EAAQC,GACzBmH,EAAUmL,EAAWvS,EAAQC,GAAMuS,EAAMxP,EAAIyP,EAAMxP,EAAIyP,EAAM5L,EAAI6L,EAAM3L,EAAI4L,EAAMxD,EACjFyD,EAAelU,MAAQyI,EAGzB,SAAS6G,IACP4D,EAAe7O,EAAIC,EAAI2E,EAASd,EAAIE,EAAIoI,EAAIoD,EAAKC,EAAKF,EAAUG,EAAKC,EAAKC,EAAKtB,GAAUxT,GACzF+U,EAAerT,QAAUA,EACzBA,IAGF,OAAOqT,GAIX,IAAIE,GAAmBpC,GAAY,CACjChS,MAAO,SAASjE,EAAGyB,GACjBN,KAAKiC,OAAOa,MAAMjE,EAAIsC,EAASb,EAAIa,MAIvC,SAASgW,GAAkBC,GACzB,IAAIxB,EAGAlO,EAAIC,EAC2CgK,EAAQ0F,EAE5CjQ,EAAIC,EAAIC,EAEnBgQ,EACAC,EARA5S,EAAI,IACJ6S,EAAI,IAAKC,EAAI,IACLtT,EAAS,EAAGC,EAAM,EAC1Be,EAAc,EAAGC,EAAW,EAAGC,EAAa,EAC5CqS,EAAQ,KAAMC,EAAU/E,GACxBzL,EAAK,KAAkByQ,EAAWhL,GAClCiJ,EAAS,GAAKgC,EAAkBlC,GAASmC,EAAkBjC,GAI/D,SAAS5E,EAAWnO,GAElB,MAAO,EADPA,EAAQuU,EAAcvU,EAAM,GAAK3B,EAAS2B,EAAM,GAAK3B,IACvC,GAAKwD,EAAI+C,EAAIC,EAAK7E,EAAM,GAAK6B,GAG7C,SAASK,EAAOlC,GAEd,OADAA,EAAQuU,EAAcrS,QAAQlC,EAAM,GAAK4E,GAAM/C,GAAIgD,EAAK7E,EAAM,IAAM6B,KACpD,CAAC7B,EAAM,GAAK5B,EAAS4B,EAAM,GAAK5B,GAGlD,SAAS4W,EAAiBjZ,EAAGyB,GAC3B,MAA0B,EAAnBzB,EAAI+W,EAAQ/W,EAAGyB,IAAO,GAAKqE,EAAI+C,EAAIC,EAAK9I,EAAE,GAAK8F,GA2CxD,SAASoT,IACPV,EAAgBvS,EAAQ6M,EAASzM,EAAcC,EAAaC,EAAUC,GAAauQ,GACnF,IAAIoC,EAASpC,EAAQzR,EAAQC,GAG7B,OAFAsD,EAAK8P,EAAIQ,EAAO,GAAKrT,EACrBgD,EAAK8P,EAAIO,EAAO,GAAKrT,EACd1E,IAGT,SAASA,IAEP,OADAqX,EAAQC,EAAc,KACftG,EAGT,OArDAA,EAAWhP,OAAS,SAASA,GAC3B,OAAOqV,GAASC,IAAgBtV,EAASqV,EAAQA,EAAQJ,GAAiBS,EAAQhG,EAAQkG,EAAgBD,EAASL,EAActV,OAGnIgP,EAAWgH,UAAY,SAASnI,GAC9B,OAAOwB,UAAU5S,QAAUiZ,GAAW7H,EAAIoD,GAAWwE,EAAQ5H,EAAI3O,EAAS,EAAIA,IAAYuW,EAAQ,KAAM9E,IAAmB3S,KAAWyX,EAAQxW,GAGhJ+P,EAAWzH,WAAa,SAASsG,GAC/B,OAAOwB,UAAU5S,QAAUkZ,EAAgB,MAAL9H,GAAa3I,EAAKC,EAAKC,EAAKC,EAAK,KAAMsF,IAAcpD,GAAWrC,GAAM2I,EAAE,GAAG,GAAI1I,GAAM0I,EAAE,GAAG,GAAIzI,GAAMyI,EAAE,GAAG,GAAIxI,GAAMwI,EAAE,GAAG,IAAK7P,KAAiB,MAANkH,EAAa,KAAO,CAAC,CAACA,EAAIC,GAAK,CAACC,EAAIC,KAGpN2J,EAAWoE,MAAQ,SAASvF,GAC1B,OAAOwB,UAAU5S,QAAUiG,GAAKmL,EAAGiI,KAAcpT,GAGnDsM,EAAWqE,UAAY,SAASxF,GAC9B,OAAOwB,UAAU5S,QAAU8Y,GAAK1H,EAAE,GAAI2H,GAAK3H,EAAE,GAAIiI,KAAc,CAACP,EAAGC,IAGrExG,EAAW+G,OAAS,SAASlI,GAC3B,OAAOwB,UAAU5S,QAAUyF,EAAS2L,EAAE,GAAK,IAAM3O,EAASiD,EAAM0L,EAAE,GAAK,IAAM3O,EAAS4W,KAAc,CAAC5T,EAASjD,EAASkD,EAAMlD,IAG/H+P,EAAWU,OAAS,SAAS7B,GAC3B,OAAOwB,UAAU5S,QAAUyG,EAAc2K,EAAE,GAAK,IAAM3O,EAASiE,EAAW0K,EAAE,GAAK,IAAM3O,EAASkE,EAAayK,EAAEpR,OAAS,EAAIoR,EAAE,GAAK,IAAM3O,EAAU,EAAG4W,KAAc,CAAC5S,EAAcjE,EAASkE,EAAWlE,EAASmE,EAAanE,IAG/N+P,EAAWiH,UAAY,SAASpI,GAC9B,OAAOwB,UAAU5S,QAAUmZ,EAAkBlC,GAASmC,EAAkBjC,EAAS/F,EAAIA,GAAI7P,KAAW0B,EAAKkU,IAG3G5E,EAAWiE,UAAY,SAASC,EAAQ5S,GACtC,OAAO2S,GAAUjE,EAAYkE,EAAQ5S,IAGvC0O,EAAWsE,QAAU,SAASC,EAAMjT,GAClC,OAAOgT,GAAQtE,EAAYuE,EAAMjT,IAgB5B,WAGL,OAFAqT,EAAUwB,EAAU/F,MAAMrR,KAAMsR,WAChCL,EAAWjM,OAAS4Q,EAAQ5Q,QAAUA,EAC/B+S,KAIX,SAASI,GAAgBf,GACvB,IAAIpL,EAAO,EACPM,EAAOxL,EAAK,EACZzB,EAAI8X,GAAkBC,GACtBhP,EAAI/I,EAAE2M,EAAMM,GAMhB,OAJAlE,EAAEgQ,UAAY,SAAStI,GACrB,OAAOwB,UAAU5S,OAASW,EAAE2M,EAAO8D,EAAE,GAAK3O,EAASmL,EAAOwD,EAAE,GAAK3O,GAAW,CAAC6K,EAAO9K,EAASoL,EAAOpL,IAG/FkH,EAGT,SAASiQ,GAAwBrM,GAC/B,IAAIE,EAAU3K,EAAIyK,GAElB,SAASsM,EAAQnU,EAAQC,GACvB,MAAO,CAACD,EAAS+H,EAAS1K,EAAI4C,GAAO8H,GAOvC,OAJAoM,EAAQtT,OAAS,SAASnG,EAAGyB,GAC3B,MAAO,CAACzB,EAAIqN,EAASrK,EAAKvB,EAAI4L,KAGzBoM,EAGT,SAASC,GAAkBnR,EAAIE,GAC7B,IAAIkR,EAAMhX,EAAI4F,GAAK5H,GAAKgZ,EAAMhX,EAAI8F,IAAO,EAGzC,GAAIlG,EAAI5B,GAAKqB,EAAS,OAAOwX,GAAwBjR,GAErD,IAAIsM,EAAI,EAAI8E,GAAO,EAAIhZ,EAAIgZ,GAAMC,EAAK9W,EAAK+R,GAAKlU,EAEhD,SAASoW,EAAQ/W,EAAGyB,GAClB,IAAIiH,EAAI5F,EAAK+R,EAAI,EAAIlU,EAAIgC,EAAIlB,IAAMd,EACnC,MAAO,CAAC+H,EAAI/F,EAAI3C,GAAKW,GAAIiZ,EAAKlR,EAAIhG,EAAI1C,IAQxC,OALA+W,EAAQ5Q,OAAS,SAASnG,EAAGyB,GAC3B,IAAIoY,EAAMD,EAAKnY,EACf,MAAO,CAACgB,EAAMzC,EAAGuC,EAAIsX,IAAQlZ,EAAIiC,EAAKiX,GAAM7W,GAAM6R,GAAK7U,EAAIA,EAAI6Z,EAAMA,GAAOlZ,EAAIA,IAAM,EAAIA,MAGrFoW,EAGT,SAAS+C,KACP,OAAOR,GAAgBI,IAClBlD,MAAM,SACN2C,OAAO,CAAC,EAAG,UAGlB,SAASY,KACP,OAAOD,KACFP,UAAU,CAAC,KAAM,OACjB/C,MAAM,MACNC,UAAU,CAAC,IAAK,MAChB3D,OAAO,CAAC,GAAI,IACZqG,OAAO,EAAC,GAAM,OAGrB,SAASa,GAAWha,GAClB,OAAOA,EAGT,SAASia,GAAYC,GACnB,GAAiB,MAAbA,EAAmB,OAAOF,GAC9B,IAAI1R,EACAC,EACA4R,EAAKD,EAAU1D,MAAM,GACrB4D,EAAKF,EAAU1D,MAAM,GACrB3N,EAAKqR,EAAUzD,UAAU,GACzB3N,EAAKoR,EAAUzD,UAAU,GAC7B,OAAO,SAAS4D,EAAOzZ,GAChBA,IAAG0H,EAAKC,EAAK,GAClB,IAAI1H,EAAI,EAAGF,EAAI0Z,EAAMxa,OAAQya,EAAS,IAAIxZ,MAAMH,GAGhD,IAFA2Z,EAAO,IAAMhS,GAAM+R,EAAM,IAAMF,EAAKtR,EACpCyR,EAAO,IAAM/R,GAAM8R,EAAM,IAAMD,EAAKtR,EAC7BjI,EAAIF,GAAG2Z,EAAOzZ,GAAKwZ,EAAMxZ,KAAMA,EACtC,OAAOyZ,GAIX,SAASC,GAAQ7Z,EAAOC,GAEtB,IADA,IAAIY,EAAGV,EAAIH,EAAMb,OAAQe,EAAIC,EAAIF,EAC1BC,IAAMC,GAAGU,EAAIb,EAAME,GAAIF,EAAME,KAAOF,EAAMG,GAAIH,EAAMG,GAAKU,EAGlE,SAASiZ,GAAYC,EAAUC,GAC7B,MAAkB,uBAAXA,EAAEnX,KACH,CAACA,KAAM,oBAAqBK,SAAU8W,EAAEhW,WAAWiW,KAAI,SAASvR,GAAK,OAAOwR,GAAQH,EAAUrR,OAC9FwR,GAAQH,EAAUC,GAG1B,SAASE,GAAQH,EAAUrR,GACzB,IAAIyR,EAAKzR,EAAEyR,GACPC,EAAO1R,EAAE0R,KACTC,EAA6B,MAAhB3R,EAAE2R,WAAqB,GAAK3R,EAAE2R,WAC3C5X,EAAW6X,GAASP,EAAUrR,GAClC,OAAa,MAANyR,GAAsB,MAARC,EAAe,CAACvX,KAAM,UAAWwX,WAAYA,EAAY5X,SAAUA,GAC1E,MAAR2X,EAAe,CAACvX,KAAM,UAAWsX,GAAIA,EAAIE,WAAYA,EAAY5X,SAAUA,GAC3E,CAACI,KAAM,UAAWsX,GAAIA,EAAIC,KAAMA,EAAMC,WAAYA,EAAY5X,SAAUA,GAGhF,SAAS6X,GAASP,EAAUQ,GAC1B,IAAIC,EAAiBjB,GAAYQ,EAASP,WACtCiB,EAAOV,EAASW,KAEpB,SAASxN,EAAIhN,EAAGqI,GACVA,EAAOpJ,QAAQoJ,EAAOhB,MAC1B,IAAK,IAAIzI,EAAI2b,EAAKva,EAAI,GAAKA,EAAIA,GAAIkF,EAAI,EAAGnF,EAAInB,EAAEK,OAAQiG,EAAInF,IAAKmF,EAC/DmD,EAAOlB,KAAKmT,EAAe1b,EAAEsG,GAAIA,IAE/BlF,EAAI,GAAG2Z,GAAQtR,EAAQtI,GAG7B,SAASsD,EAAMsF,GACb,OAAO2R,EAAe3R,GAGxB,SAAS1B,EAAKuT,GAEZ,IADA,IAAInS,EAAS,GACJrI,EAAI,EAAGD,EAAIya,EAAKvb,OAAQe,EAAID,IAAKC,EAAGgN,EAAIwN,EAAKxa,GAAIqI,GAE1D,OADIA,EAAOpJ,OAAS,GAAGoJ,EAAOlB,KAAKkB,EAAO,IACnCA,EAGT,SAASoD,EAAK+O,GAEZ,IADA,IAAInS,EAASpB,EAAKuT,GACXnS,EAAOpJ,OAAS,GAAGoJ,EAAOlB,KAAKkB,EAAO,IAC7C,OAAOA,EAGT,SAASmC,EAAQgQ,GACf,OAAOA,EAAKT,IAAItO,GAGlB,SAASlJ,EAASiG,GAChB,IAAmBpF,EAAfT,EAAO6F,EAAE7F,KACb,OAAQA,GACN,IAAK,qBAAsB,MAAO,CAACA,KAAMA,EAAMmB,WAAY0E,EAAE1E,WAAWiW,IAAIxX,IAC5E,IAAK,QAASa,EAAcC,EAAMmF,EAAEpF,aAAc,MAClD,IAAK,aAAcA,EAAcoF,EAAEpF,YAAY2W,IAAI1W,GAAQ,MAC3D,IAAK,aAAcD,EAAc6D,EAAKuB,EAAEgS,MAAO,MAC/C,IAAK,kBAAmBpX,EAAcoF,EAAEgS,KAAKT,IAAI9S,GAAO,MACxD,IAAK,UAAW7D,EAAcoH,EAAQhC,EAAEgS,MAAO,MAC/C,IAAK,eAAgBpX,EAAcoF,EAAEgS,KAAKT,IAAIvP,GAAU,MACxD,QAAS,OAAO,KAElB,MAAO,CAAC7H,KAAMA,EAAMS,YAAaA,GAGnC,OAAOb,EAAS8X,GAKlB,SAASI,GAAqBC,EAAIC,GACjC,OAAiCD,EAA1BC,EAAS,CAAEjc,QAAS,IAAiBic,EAAOjc,SAAUic,EAAOjc,QA6DrE,SAASkc,KAgCN,IAAIC,EAAa,EACZrJ,EAAa2H,KACbgB,EAAa,SAASF,GAClB,MAAO,IAEXa,EAAQ,SAAStc,GACb,OAAO,GAGjB,SAASuc,EAAUlB,EAAU/V,GAG3B+V,EAAWmB,EAAKnB,GAOZ,IAFJ,IAAyCza,EAAEyB,EAAUoa,EAAjDC,EAAKC,EAAYtB,EAASP,WAA4B8B,EAAKvB,EAASW,KAAKvb,OAAOoc,EAAG,EACnFC,EAAgB,IAAIpb,MAAMkb,GACpBC,EAAGD,GAAK,CAMZ,IALAhc,EAAI,EACJyB,EAAI,EACJ0a,EAAO1B,EAASW,KAAKa,GAAIpc,OACzBuc,EAAK,EACLP,EAAO,IAAI/a,MAAMqb,GACXC,EAAGD,GACP1B,EAASW,KAAKa,GAAIG,GAAI,GAAMpc,GAAKya,EAASW,KAAKa,GAAIG,GAAI,GACvD3B,EAASW,KAAKa,GAAIG,GAAI,GAAM3a,GAAKgZ,EAASW,KAAKa,GAAIG,GAAI,GACvDP,EAAKO,GAAqB,OAAfhK,EAAsB0J,EAAGrB,EAASW,KAAKa,GAAIG,IAAOhK,EAAW0J,EAAGrB,EAASW,KAAKa,GAAIG,KAC7FA,IAEFF,EAAcD,KAAMJ,EAK1B,IAAItJ,EAAOJ,KACRC,WAAW,MAEViK,EAAU3Y,EAAOwY,EAAe,CAAC3Y,KAAM,qBAAsBmB,WAAYA,IACxEA,WAAWiW,KAAI,SAAS2B,GACvB,MAAO,CACL/Y,KAAM,UACNsX,GAAIyB,EAAKzB,GACTE,WAAYA,EAAWwB,KAAK,KAAMD,EAAM7B,GACxCtX,SAAUmZ,MAIdE,EAASH,EAAQ1B,IAAIe,GACrBe,EAAa1b,EAAIyb,GAGrB,GAAIf,GAAc,EAChB,OAAOY,EAIT,IADA,IAAIzb,EAAI,EACDA,IAAM6a,GAAY,CACvB,IAiCIU,EAAKC,EAAwChV,EAAMsV,EAAKC,EAAGpM,EAASqM,EAAKC,EAAOC,EAASjU,EAAGC,EAAGiU,EAAYC,EAAKC,EAjChHC,EAAQb,EAAQ1B,IAAIpI,EAAK9D,MACrB0O,EAAYpc,EAAImc,GACpBE,EAAe,EACfC,EAAc,EACdC,EAAOjB,EAAQ1B,KAAI,SAASvR,EAAGvI,GAC7B,IAAI4N,EAAOzP,KAAKuD,IAAI2a,EAAMrc,IACtByI,GAAKkT,EAAO3b,GACZ0c,EAAUJ,EAAY7T,EAAImT,EAC1BtV,EAASnI,KAAK8D,KAAK2L,EAAOzP,KAAKC,IAC/Bue,EAAOxe,KAAK8D,KAAKya,EAAUve,KAAKC,IAAMkI,EACtCsW,EAAYze,KAAK2N,IAAI8B,EAAM8O,GAAWve,KAAK4N,IAAI6B,EAAM8O,GAIzD,OAHAH,GAAeK,EACfJ,IAEO,CACLxC,GAAYzR,EAAEyR,GACdpM,KAAYA,EACZ8B,SAAYgC,EAAKhC,SAASnH,GAC1BsS,MAAYpS,EACZiU,QAAYA,EACZpW,OAAYA,EACZqW,KAAYA,EACZC,UAAYA,MAIhBC,EAAYN,EAAcC,EAC1BM,EAAuB,GAAK,EAAID,GAOpC,IADkB1B,EAAKE,EAAcrc,OAAOoc,EAAG,EACzCA,EAAGD,GAAK,CAGV,IAFAG,EAAKD,EAAcD,GAAIpc,OACvBuc,EAAG,EACGA,EAAGD,GAAK,CAKZ,IAHA/U,EAAQ,CAAC,EAAE,GACXsV,EAAOY,EAAKzd,OACZ8c,EAAG,EACGA,EAAGD,GACPnM,EAAY+M,EAAKX,GAAIpM,SACrBqM,EAAYU,EAAKX,GAAIa,KAErBV,GADAD,EAAYS,EAAKX,GAAIxV,QACF0V,EAGnBE,GAFAlU,EAAKqT,EAAcD,GAAIG,GAAI,GAAK7L,EAAS,IAEtB1H,GADnBC,EAAKoT,EAAcD,GAAIG,GAAI,GAAK7L,EAAS,IACZzH,EAE7BmU,GADAD,EAAKhe,KAAK8D,KAAKia,IACDF,EACVD,EAAOC,EAASG,EAChBJ,GACCG,EAAcD,IACd,EAAI,EAAIE,EAAOH,GACpBzV,EAAM,IAAK6V,EAAMW,EAAU9U,EAAGD,GAC9BzB,EAAM,IAAK6V,EAAMY,EAAU/U,EAAGD,GAC9B8T,IAEJT,EAAcD,GAAIG,GAAI,IAAOhV,EAAM,GAAGuW,EACtCzB,EAAcD,GAAIG,GAAI,IAAOhV,EAAM,GAAGuW,EACtCvB,IAEFH,IAIF,GAAIyB,GAAa,EAAG,MAGtB,MAAO,CACL9Z,SAAUyY,EACVjB,KAAMc,GAIV,SAAS0B,EAAU/U,EAAGC,GACpB,GAAS,IAALA,EAAQ,OAAO,EACnB,IAAIgV,EAAMjV,EAAGC,EACb,OAAQA,EAAG,EACR,EAAE9J,KAAK8D,KAAK,EAAGgb,EAAIA,IACnB,EAAG9e,KAAK8D,KAAK,EAAGgb,EAAIA,GAGzB,SAASD,EAAUhV,EAAGC,GACpB,GAAS,IAALA,EAAQ,OAAO,EACnB,IAAIgV,EAAMjV,EAAGC,EACb,OAAQA,EAAG,EACRgV,EAAI9e,KAAK8D,KAAK,EAAGgb,EAAIA,IACpBA,EAAI9e,KAAK8D,KAAK,EAAGgb,EAAIA,GAG3B,SAASlC,EAAKxS,GACZ,OAAQA,aAAatI,MACjBsI,EAAEuR,IAAIiB,GACQ,iBAANxS,GAA+B,iBAANA,EAC/BA,EACA2U,EAAW3U,GAGnB,SAAS2U,EAAW3U,GAClB,IAAI4U,EAAM,GACV,IAAK,IAAIlY,KAAKsD,EAAG4U,EAAIlY,GAAK8V,EAAKxS,EAAEtD,IACjC,OAAOkY,EAGT,SAASta,EAAOua,EAAMC,GACpB,SAAStQ,EAAIhN,EAAGqI,GACVA,EAAOpJ,QAAQoJ,EAAOhB,MAC1B,IAAK,IAAIzI,EAAIye,EAAKrd,EAAI,GAAKA,EAAIA,GAAIkF,EAAI,EAAGnF,EAAInB,EAAEK,OAAQiG,EAAInF,IAAKmF,EAC/DmD,EAAOlB,KAAKvI,EAAEsG,IAEZlF,EAAI,GAAGud,EAAQlV,EAAQtI,GAG7B,SAASkH,EAAKuT,GAEZ,IADA,IAAInS,EAAS,GACJrI,EAAI,EAAGD,EAAIya,EAAKvb,OAAQe,EAAID,IAAKC,EAAGgN,EAAIwN,EAAKxa,GAAIqI,GAC1D,OAAOA,EAGT,SAASmC,EAAQgQ,GACf,OAAOA,EAAKT,IAAI9S,GAGlB,SAAS1E,EAASiG,GAGhB,OAFAA,EAAIgV,OAAOC,OAAOjV,IAChBpF,YAAcsa,EAAalV,EAAE7F,MAAM6F,EAAEgS,MAChChS,EAGT,IAAIkV,EAAe,CACfna,WAAY0D,EACZxD,gBAAiB+G,EACjB9G,QAAS8G,EACT5G,aAAc,SAAS4W,GAAQ,OAAOA,EAAKT,IAAIvP,KAGnD,MAAkB,uBAAX8S,EAAE3a,OACA2a,EAAIE,OAAOC,OAAOH,IAAMxZ,WAAawZ,EAAExZ,WAAWiW,IAAIxX,GAAW+a,GAClE/a,EAAS+a,GAGnB,SAASC,EAAQzd,EAAOC,GACgB,IAApC,IAAIY,EAAGV,EAAIH,EAAMb,OAAQe,EAAIC,EAAIF,EAAUC,IAAMC,GAAGU,EAAIb,EAAME,GAAIF,EAAME,KAAOF,EAAMG,GAAIH,EAAMG,GAAKU,EA6DxG,SAASgd,EAASve,GAChB,OAAO,WACL,OAAOA,GA3DX2b,EAAUpJ,KAAOJ,KACVC,WAAW,MAElBuJ,EAAUF,WAAa,SAAS7a,GAC1B,OAAI6R,UAAU5S,QACZ4b,EAAa7a,EACN+a,GAEAF,GAIfE,EAAUD,MAAQ,SAASpS,GACrB,OAAImJ,UAAU5S,QACZ6b,EAAqB,mBAANpS,EAAmBA,EAAIiV,EAASjV,GACxCqS,GAEAD,GAIfC,EAAUvJ,WAAa,SAAS7I,GAC1B,OAAIkJ,UAAU5S,QACZuS,EAAa7I,EACNoS,GAEAvJ,GAIfuJ,EAAUf,QAAU,SAASH,EAAU6B,GACjC,MAAO,CACL/Y,KAAM,UACNsX,GAAIyB,EAAKzB,GACTE,WAAYA,EAAWwB,KAAK,KAAMD,EAAM7B,GACxCtX,SAAU,CACRI,KAAM+Y,EAAK/Y,KACXS,YAAawW,GAAYC,EAAU6B,GAAMnZ,SAASa,eAK5D2X,EAAU/X,SAAW,SAAS4a,EAAM9Z,GAClC,OAAOA,EAAWiW,KAAI,SAASta,GAC7B,OAAOsb,EAAUf,QAAQ4D,EAAMne,OAInCsb,EAAUZ,WAAa,SAAS0D,GAC9B,OAAIhM,UAAU5S,QACZkb,EAA8B,mBAAV0D,EAAuBA,EAAQF,EAASE,GACrD9C,GAEAZ,GAWX,IAAIgB,EAAcJ,EAAUI,YAAc,SAASD,GAC/C,IAAI3B,EAAK2B,EAAGtF,MAAM,GACd4D,EAAK0B,EAAGtF,MAAM,GACd3N,EAAKiT,EAAGrF,UAAU,GAClB3N,EAAKgT,EAAGrF,UAAU,GAEtB,SAASyD,EAAUrF,GACjB,MAAO,CAACA,EAAE,GAAKsF,EAAKtR,EAAIgM,EAAE,GAAKuF,EAAKtR,GAOtC,OAJAoR,EAAU/T,OAAS,SAAS0O,GAC1B,MAAO,EAAEA,EAAE,GAAKhM,GAAMsR,GAAKtF,EAAE,GAAI/L,GAAMsR,IAGlCF,GAGX,OAAOyB,EAjY8B,oBAAX+C,OAAyBA,YAA2B,IAAXC,GAAkD,oBAATC,MAAuBA,KAMzHvD,IAAqB,SAAUE,EAAQjc,IACjD,SAAUuf,EAAMC,EAAMC,GAEpBxD,EAAOjc,QAAUyf,IAFnB,CAKA,EAASC,GAAgB,WASzB,OAAO,SAAUC,GACf,IAAIC,EAAQD,aAAkBne,MAAS,GAAK,GAoB5C,OAnBE,SAASqe,EAAMC,EAAQxD,GACvB,IAAK,IAAIxF,KAAOgJ,EAAQ,CACtB,IAAIpB,EAAMoB,EAAOhJ,GACb4H,aAAeld,MAGjBqe,EAAKnB,EADMxc,EAAIoa,EAAMxF,EADT,KAIL4H,aAAeI,QAAyB,mBAARJ,EAGvCmB,EAAKnB,EADMxc,EAAIoa,EAAMxF,EADT,KAMZ5U,EAAIoa,EAAMxF,EADE4H,IAdhB,CAkBAiB,EAAQC,GACHA,GAST,SAAS1d,EAAKoa,EAAMxF,EAAKsF,GACvB,OAAIE,aAAgB9a,OAClB8a,EAAK7T,KAAK2T,GACHE,EAAKA,EAAK/b,OAAS,IAEnB+b,aAAgBwC,QACvBxC,EAAKxF,GAAOsF,EACLE,EAAKxF,SAFT,SA4UT9W,EAAQqc,UAAYH,GAEpB4C,OAAOiB,eAAe/f,EAAS,aAAc,CAAEoc,OAAO,IAvmFSqD,CAAQO,GCGxEC,SAASC,cAAc,WAAWC,UAAUje,IAAI,QAChD,IAAIke,EAAS,CAAC,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAC/G,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,WAEjGC,EAAcJ,SAASC,cAAc,gBACrCI,EAAeL,SAASC,cAAc,uBAEtCK,EAAiBN,SAASC,cAAc,aAExCM,EAAYP,SAASC,cAAc,cACnCO,EAAaR,SAASC,cAAc,qBAExCI,EAAaI,iBAAiB,SAAS,KACrCL,EAAcJ,SAASC,cAAc,gBACrCD,SAASC,cAAc,WAAWC,UAAUQ,OAAO,QACnDC,OAGFH,EAAWC,iBAAiB,SAAS,KACnCF,EAAYP,SAASC,cAAc,cACnCD,SAASC,cAAc,WAAWC,UAAUQ,OAAO,QACnDC,OAGFL,EAAeG,iBAAiB,aAAa,KAC3CG,QAAQC,IAAI,QACZC,GAAGC,OAAO,aAAaC,GAAG,SAAS,WACjCF,GAAGC,OAAOnf,MACPqf,KAAK,OAAQ,wCAA0CC,KAAKJ,GAAGC,OAAO,cAAcI,SACpFF,KAAK,WAAY,uBAIxB,MAAMG,EAAgB,GAAhBA,EAAuC,GAAvCA,EAAiD,GACjDC,EAAQ,KAAOD,EADY,GAE3BE,EAAS,IAAMF,EAAaA,EAGlC,SAAST,IACP,IAAIY,EAAYnB,EAAYjE,MAC5B,MAAMqF,EAAWV,GAAGW,KAAK,2GACnBC,EAAUZ,GAAGa,IAAI,6GACvBC,QAAQC,IAAI,CAACL,EAAUE,IAAUI,MAAKC,IACpC,IAAKC,EAAUC,GAAWF,GAO9B,SAAkB9C,EAAMvW,EAAK6Y,EAAWW,GACtC,IAAIC,EAA0B,IAAZZ,EACda,EAAOf,EAAQc,EACfE,EAAO5iB,KAAK6iB,KAAKhB,EAASa,GAC1BI,EAAYzB,GAAG0B,MAAMH,EAAOD,GAAMhH,KAAI,SAAUqH,EAAIphB,GACtD,MAAO,CACLZ,EAAGhB,KAAKijB,MAAMrhB,EAAI+gB,GAAQD,EAC1BjgB,EAAGzC,KAAKijB,MAAMrhB,EAAI+gB,GAAQD,EAC1BQ,UAAW,MAIf,IAAIC,EA4MN,SAAiBC,GACf,IAAIpE,EAAM,GACV,IAAK,IAAIhe,KAAKoiB,EACZpE,EAAIoE,EAAKpiB,GAAGgW,MAAQoM,EAAKpiB,GAE3B,OAAOge,EAjNcqE,CAAQpa,GAEzB0T,EAAY2D,EAAA3D,YACbvJ,WAAW,MACX2I,YAAW,SAAU3b,GACpB,OAAOA,EAAE2b,cAEVW,OAAM,SAAUtc,GAEf,OADmBA,EAAE2b,WAAWuH,SAIpC3G,EAAU/X,SAAS4a,EAAMA,EAAKnC,QAAQkG,MAAM7d,YAEhC2b,GAAGmC,cACZC,OAAO,CAAC,EAAG,MACXV,MAAM,CAAC,EAAG,MAEbpG,EAAUD,OAAM,SAAUtc,GAExB,OADmB+iB,EAAe/iB,EAAE2b,WAAWF,IAAIiF,EAAUpE,UAI/D,IAAIgH,EAAe/G,EAAU6C,EAAMA,EAAKnC,QAAQkG,MAAM7d,YAAYd,SAElE,IAAIA,EAAW,GACf,IAAK,IAAIqY,EAAI,EAAGA,EAAIyG,EAAa7iB,OAAQoc,IAAK,CAC5C,IAAI0G,EAAe,GACnB,GAAqC,gBAAjCD,EAAazG,GAAG9Y,SAASI,KAC3B,IAAK,IAAI1C,EAAI,EAAGA,EAAI6hB,EAAazG,GAAG9Y,SAASa,YAAYnE,OAAQgB,IAC/D8hB,EAAa9hB,GAAK6hB,EAAazG,GAAG9Y,SAASa,YAAYnD,GAAG,OAGpB,WAAjC6hB,EAAazG,GAAG9Y,SAASI,OAChCof,EAAa,GAAKD,EAAazG,GAAG9Y,SAASa,YAAY,IAEzDJ,EAASqY,GAAK,CACZjY,YAAe2e,EACf5H,WAAc2H,EAAazG,GAAGlB,YAIlCsF,GAAGC,OAAO,cAAcsC,UAAU,KAAK3C,SAEvC,IAAI4C,EFnGS,WACb,IAMIna,EACAoa,EACAC,EARAC,EAAK,EACLC,EAAK,EACLlU,EAAK,EACLC,EAAK,EACLwI,EAAIrY,EACJsY,EAAIpY,EAKR,SAAS6jB,EAAOja,GACd,IAA8BrI,EAA1BuiB,EAAW,GAAIC,EAAO,GAAOziB,EAAIsI,EAAOpJ,OAE5C,IAAKe,EAAI,EAAGA,EAAID,IAAKC,EACnB,IAAIyiB,MAAMC,GAAM9L,EAAE+E,KAAK,KAAMtY,EAAQgF,EAAOrI,GAAIA,EAAGqI,MAC5Coa,MAAME,GAAM9L,EAAE8E,KAAK,KAAMtY,EAAOrD,EAAGqI,IAD1C,CAGA,IAAIhF,EACAqf,EACAC,EACAC,EAAKxkB,KAAKykB,MAAMF,GAAUR,GAC1B9gB,EAAKjD,KAAKykB,MAAMH,EAAKA,EAAKR,GAAW,EAALU,GAAU,GAC1CE,EAAMH,EAAKC,EAEf,GAAoB,EAAhBxkB,KAAKuD,IAAImhB,GAAW,EAAG,CACzB,IAAIC,EAAML,EAAKrhB,EACX2hB,EAAM3hB,GAAMqhB,EAAKrhB,GAAK,EAAK,GAAK,EAChC4hB,EAAML,GAAMD,EAAKC,GAAK,EAAK,GAC3BM,EAAMR,EAAKM,EACXG,EAAMR,EAAKM,EACXF,EAAMA,EAAMD,EAAMA,EAAMI,EAAMA,EAAMC,EAAMA,IAAK9hB,EAAK2hB,GAAY,EAALJ,EAAS,GAAI,GAAM,EAAGA,EAAKK,GAG5F,IAAIhJ,EAAK5Y,EAAK,IAAMuhB,EAAIQ,EAAMb,EAAStI,GACnCmJ,EAAKA,EAAIjc,KAAK9D,IAEhBmf,EAAKrb,KAAKic,EAAMb,EAAStI,GAAM,CAAC5W,IAChC+f,EAAIhkB,GAAKiC,GAAW,EAALuhB,GAAU,GAAKV,EAC9BkB,EAAIviB,EAAI+hB,EAAKT,GAIjB,OAAOK,EAGT,SAASa,EAAQ9c,GACf,IAAImB,EAAK,EAAGC,EAAK,EACjB,OAAOrJ,EAAOyb,KAAI,SAAS3N,GACzB,IAAIxE,EAAKxJ,KAAK2D,IAAIqK,GAAS7F,EACvBsB,GAAMzJ,KAAK0D,IAAIsK,GAAS7F,EACxB0B,EAAKL,EAAKF,EACVQ,EAAKL,EAAKF,EAEd,OADAD,EAAKE,EAAID,EAAKE,EACP,CAACI,EAAIC,MA6ChB,OAzCAoa,EAAOe,QAAU,SAAS9c,GACxB,MAAO,IAAM8c,EAAkB,MAAV9c,EAAiBuB,GAAKvB,GAAQ2M,KAAK,KAAO,KAGjEoP,EAAOgB,QAAU,WAIf,IAHA,IAAIA,EAAU,GACVrjB,EAAI7B,KAAKykB,MAAMR,EAAKF,GACpBniB,EAAI5B,KAAKykB,MAAMT,EAAKF,GACfrhB,EAAIZ,EAAIkiB,EAAIthB,EAAIuN,EAAKtG,EAAGjH,GAAKshB,IAAMliB,EAC1C,IAAK,IAAIb,EAAIY,EAAIkiB,GAAU,EAAJjiB,GAASiiB,EAAK,EAAG9iB,EAAI+O,EAAK+T,EAAK,EAAG9iB,GAAK8iB,EAC5DoB,EAAQnc,KAAK,CAAC/H,EAAGyB,IAGrB,OAAOyiB,GAGThB,EAAOiB,KAAO,WACZ,IAAIC,EAAWH,EAAQvb,GAAG2b,MAAM,EAAG,GAAGvQ,KAAK,KAC3C,OAAOoP,EAAOgB,UAAUvJ,KAAI,SAASpR,GAAK,MAAO,IAAMA,EAAI,IAAM6a,KAAatQ,KAAK,KAGrFoP,EAAOljB,EAAI,SAASiR,GAClB,OAAOwB,UAAU5S,QAAU2X,EAAIvG,EAAGiS,GAAU1L,GAG9C0L,EAAOzhB,EAAI,SAASwP,GAClB,OAAOwB,UAAU5S,QAAU4X,EAAIxG,EAAGiS,GAAUzL,GAG9CyL,EAAO/b,OAAS,SAAS8J,GACvB,OAAOwB,UAAU5S,QAAkBijB,EAAS,GAAjBpa,GAAKuI,GAAgBjS,KAAK2D,IAAI5D,GAAUgkB,EAAS,IAAJra,EAASwa,GAAUxa,GAG7Fwa,EAAOvM,KAAO,SAAS1F,GACrB,OAAOwB,UAAU5S,QAAUmjB,EAAKC,EAAK,EAAGlU,GAAMkC,EAAE,GAAIjC,GAAMiC,EAAE,GAAIiS,GAAU,CAACnU,EAAKiU,EAAIhU,EAAKiU,IAG3FC,EAAO5M,OAAS,SAASrF,GACvB,OAAOwB,UAAU5S,QAAUmjB,GAAM/R,EAAE,GAAG,GAAIgS,GAAMhS,EAAE,GAAG,GAAIlC,GAAMkC,EAAE,GAAG,GAAIjC,GAAMiC,EAAE,GAAG,GAAIiS,GAAU,CAAC,CAACF,EAAIC,GAAK,CAAClU,EAAIC,KAG5GkU,EAAO/b,OAAO,GEALmd,GACbnd,OAAO2Z,GACP9gB,GAAE,SAAUZ,GAAK,OAAOA,EAAEY,KAC1ByB,GAAE,SAAUrC,GAAK,OAAOA,EAAEqC,KAE7B,MAAM8iB,EAAMlE,GAAGC,OAAO,cACnBkE,OAAO,OACPhE,KAAK,QAASI,EAAQD,EAAcA,GACpCH,KAAK,SAAUK,EAASF,EAAaA,GACrC6D,OAAO,KACPhE,KAAK,YAAa,aAAaG,KAAeA,MAEjD4D,EAAIC,OAAO,KAAKhE,KAAK,KAAM,SACxBoC,UAAU,QACVR,KAAKS,EAAUf,IACf2C,QAAQD,OAAO,QACfhE,KAAK,QAAS,OACdA,KAAK,aAAa,SAAUphB,GAAK,MAAO,aAAeA,EAAEY,EAAI,KAAOZ,EAAEqC,EAAI,OAC1E+e,KAAK,IAAKqC,EAAUoB,WACpBS,MAAM,OAAQ,QACdA,MAAM,SAAU,WAChBA,MAAM,eA3FS,IA4FfnE,GAAG,QAASoE,GAEf,IAAK,IAAIvI,EAAI,EAAGA,EAAIxY,EAAS/D,OAAQuc,IACnC,IAAK,IAAIvb,EAAI,EAAGA,EAAI+C,EAASwY,GAAGpY,YAAYnE,OAAQgB,IAAK,CACvD,IAAI+jB,EAAgBhhB,EAASwY,GAAGpY,YAAYnD,GAE5C,IAKIgkB,EAAYhC,EALDf,EAAUgD,QAAO,SAAUC,EAAK/C,GAE7C,OADI3B,GAAGvT,gBAAgB8X,EAAe,CAAC5C,EAAGhiB,EAAGgiB,EAAGvgB,KAAKsjB,EAAIhd,KAAKia,GACvD+C,IACN,KAIHR,EAAIC,OAAO,KACRhE,KAAK,KAAM,SACXoC,UAAU,QACVR,KAAKyC,GACLJ,QAAQD,OAAO,QACfhE,KAAK,QAAS,MAAQ5c,EAASwY,GAAGrB,WAAWF,IAC7C2F,KAAK,aAAa,SAAUphB,GAAK,MAAO,aAAeA,EAAEY,EAAI,KAAOZ,EAAEqC,EAAI,OAC1E+e,KAAK,KAAK,SAAUphB,GAAK,OAAOA,EAAEY,KAClCwgB,KAAK,KAAK,SAAUphB,GAAK,OAAOA,EAAEqC,KAClC+e,KAAK,IAAKqC,EAAUoB,WACpBS,MAAM,OAAQhF,EAAOtD,EAAI,KACzBsI,MAAM,SAAU,QAChBA,MAAM,eArHK,IAsHXnE,GAAG,QAASyE,GACZzE,GAAG,YAAa0E,GAChB1E,GAAG,WAAY2E,GACf3I,KAAK8D,GAAG8E,OACN5E,GAAG,QAAS6E,GACZ7E,GAAG,OAAQ8E,GACX9E,GAAG,MAAO+E,KAnHjBC,CAAShE,EAAUC,EAASV,GAC5BvB,SAASC,cAAc,WAAWC,UAAUje,IAAI,WAuHpD,SAASyjB,EAAM7lB,GACbihB,GAAGC,OAAOnf,MACPqkB,aACAC,SAAS,IACTf,MAAM,eAAgB,IAG3B,SAASC,EAAWvlB,GAElB,GAA2B,UADPmgB,SAASC,cAAc,iBACzB9D,MAChB2E,GAAGC,OAAOnf,MACPujB,MAAM,OAAQ,QACdA,MAAM,SAAU,WAChBA,MAAM,eA9IO,IA+IbgB,YACE,CACL,IAAIC,EAAepG,SAASC,cAAc,iBAC1Ca,GAAGC,OAAOnf,MACPujB,MAAM,eAnJO,IAoJbA,MAAM,OAAQiB,EAAajK,OAC3BgJ,MAAM,SAAU,QAChBnE,GAAG,YAAa0E,GAChB1E,GAAG,WAAY2E,GACf3I,KAAK8D,GAAG8E,OACN5E,GAAG,QAAS6E,GACZ7E,GAAG,OAAQ8E,GACX9E,GAAG,MAAO+E,IACZM,SAIP,SAASZ,EAAO5lB,GAEd,GAA2B,UADPmgB,SAASC,cAAc,iBACzB9D,MAChB2E,GAAGC,OAAOnf,MACP8e,aACE,CACL,IAAI0F,EAAepG,SAASC,cAAc,iBAC1Ca,GAAGC,OAAOnf,MACPujB,MAAM,eAxKO,IAyKbA,MAAM,OAAQiB,EAAajK,OAC3BgJ,MAAM,SAAU,QAChBnE,GAAG,YAAa0E,GAChB1E,GAAG,WAAY2E,GACf3I,KAAK8D,GAAG8E,OACN5E,GAAG,QAAS6E,GACZ7E,GAAG,OAAQ8E,GACX9E,GAAG,MAAO+E,IACZM,SAIP,SAASV,EAAK9lB,GACZihB,GAAGC,OAAOnf,MACPqkB,aACAC,SAAS,IACTf,MAAM,eAAgB,GAG3B,SAASU,EAAYS,EAAOzmB,GAC1BA,EAAE0mB,OAAQ,EACVzF,GAAGC,OAAOnf,MAAMykB,QACblB,MAAM,eAAgB,GACtBA,MAAM,SAAU,QAGrB,SAASW,EAAQQ,EAAOE,GACtB,IAAIjF,EAAYnB,EAAYjE,MAC5B,IAEIsK,EAcN,SAAehmB,EAAGyB,EAAGd,GACnB,IAAIslB,EACAC,EACAC,EAASnnB,KAAK8D,KAAK,GAAK,EACxB1D,EAAQ,EAAJuB,EACJylB,EAAKhnB,EAAI+mB,EACTE,EAAS,EAAJ1lB,EACLc,EAAI4kB,EAAK1lB,GACXulB,EAAQzkB,EAAKA,EAAI4kB,EACjBJ,EAAQjmB,EAAKA,EAAIomB,IAEjBF,EAAQzkB,GAAKrC,EAAKuB,EAAIwlB,EAAU,GAAM1kB,EAAI4kB,EAC1CJ,EAAQjmB,EAAKW,EAAIwlB,EAAWnmB,EAAIomB,GAElC,MAAO,CAACH,EAAOC,GA5BHI,CAFJT,EAAM7lB,EACN6lB,EAAMpkB,EACUqf,GACxBT,GAAGC,OAAOnf,MACPqf,KAAK,IAAKuF,EAAE/lB,EAAIgmB,EAAM,IACtBxF,KAAK,IAAKuF,EAAEtkB,EAAIukB,EAAM,IACtBxF,KAAK,aAAa,SAAUphB,GAAK,MAAO,aAAeA,EAAEY,EAAI,KAAOZ,EAAEqC,EAAI,OAG/E,SAAS6jB,EAAUO,EAAOzmB,GACxBA,EAAE0mB,OAAQ,EACVzF,GAAGC,OAAOnf,MACPujB,MAAM,eAjNS,IAkNfA,MAAM,SAAU,QA4BrBxE","sources":["node_modules/d3-hexbin/src/hexbin.js","node_modules/topogram/build/topogram.js","app.js"],"sourcesContent":["var thirdPi = Math.PI / 3,\n    angles = [0, thirdPi, 2 * thirdPi, 3 * thirdPi, 4 * thirdPi, 5 * thirdPi];\n\nfunction pointX(d) {\n  return d[0];\n}\n\nfunction pointY(d) {\n  return d[1];\n}\n\nexport default function() {\n  var x0 = 0,\n      y0 = 0,\n      x1 = 1,\n      y1 = 1,\n      x = pointX,\n      y = pointY,\n      r,\n      dx,\n      dy;\n\n  function hexbin(points) {\n    var binsById = {}, bins = [], i, n = points.length;\n\n    for (i = 0; i < n; ++i) {\n      if (isNaN(px = +x.call(null, point = points[i], i, points))\n          || isNaN(py = +y.call(null, point, i, points))) continue;\n\n      var point,\n          px,\n          py,\n          pj = Math.round(py = py / dy),\n          pi = Math.round(px = px / dx - (pj & 1) / 2),\n          py1 = py - pj;\n\n      if (Math.abs(py1) * 3 > 1) {\n        var px1 = px - pi,\n            pi2 = pi + (px < pi ? -1 : 1) / 2,\n            pj2 = pj + (py < pj ? -1 : 1),\n            px2 = px - pi2,\n            py2 = py - pj2;\n        if (px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2) pi = pi2 + (pj & 1 ? 1 : -1) / 2, pj = pj2;\n      }\n\n      var id = pi + \"-\" + pj, bin = binsById[id];\n      if (bin) bin.push(point);\n      else {\n        bins.push(bin = binsById[id] = [point]);\n        bin.x = (pi + (pj & 1) / 2) * dx;\n        bin.y = pj * dy;\n      }\n    }\n\n    return bins;\n  }\n\n  function hexagon(radius) {\n    var x0 = 0, y0 = 0;\n    return angles.map(function(angle) {\n      var x1 = Math.sin(angle) * radius,\n          y1 = -Math.cos(angle) * radius,\n          dx = x1 - x0,\n          dy = y1 - y0;\n      x0 = x1, y0 = y1;\n      return [dx, dy];\n    });\n  }\n\n  hexbin.hexagon = function(radius) {\n    return \"m\" + hexagon(radius == null ? r : +radius).join(\"l\") + \"z\";\n  };\n\n  hexbin.centers = function() {\n    var centers = [],\n        j = Math.round(y0 / dy),\n        i = Math.round(x0 / dx);\n    for (var y = j * dy; y < y1 + r; y += dy, ++j) {\n      for (var x = i * dx + (j & 1) * dx / 2; x < x1 + dx / 2; x += dx) {\n        centers.push([x, y]);\n      }\n    }\n    return centers;\n  };\n\n  hexbin.mesh = function() {\n    var fragment = hexagon(r).slice(0, 4).join(\"l\");\n    return hexbin.centers().map(function(p) { return \"M\" + p + \"m\" + fragment; }).join(\"\");\n  };\n\n  hexbin.x = function(_) {\n    return arguments.length ? (x = _, hexbin) : x;\n  };\n\n  hexbin.y = function(_) {\n    return arguments.length ? (y = _, hexbin) : y;\n  };\n\n  hexbin.radius = function(_) {\n    return arguments.length ? (r = +_, dx = r * 2 * Math.sin(thirdPi), dy = r * 1.5, hexbin) : r;\n  };\n\n  hexbin.size = function(_) {\n    return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], hexbin) : [x1 - x0, y1 - y0];\n  };\n\n  hexbin.extent = function(_) {\n    return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], hexbin) : [[x0, y0], [x1, y1]];\n  };\n\n  return hexbin.radius(1);\n}\n","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.topogram = global.topogram || {})));\n}(this, function (exports) { 'use strict';\n\n\tfunction ascending(a, b) {\n\t  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n\t}\n\n\tfunction bisector(compare) {\n\t  if (compare.length === 1) compare = ascendingComparator(compare);\n\t  return {\n\t    left: function(a, x, lo, hi) {\n\t      if (lo == null) lo = 0;\n\t      if (hi == null) hi = a.length;\n\t      while (lo < hi) {\n\t        var mid = lo + hi >>> 1;\n\t        if (compare(a[mid], x) < 0) lo = mid + 1;\n\t        else hi = mid;\n\t      }\n\t      return lo;\n\t    },\n\t    right: function(a, x, lo, hi) {\n\t      if (lo == null) lo = 0;\n\t      if (hi == null) hi = a.length;\n\t      while (lo < hi) {\n\t        var mid = lo + hi >>> 1;\n\t        if (compare(a[mid], x) > 0) hi = mid;\n\t        else lo = mid + 1;\n\t      }\n\t      return lo;\n\t    }\n\t  };\n\t}\n\n\tfunction ascendingComparator(f) {\n\t  return function(d, x) {\n\t    return ascending(f(d), x);\n\t  };\n\t}\n\n\tvar ascendingBisect = bisector(ascending);\n\n\tfunction merge(arrays) {\n\t  var n = arrays.length,\n\t      m,\n\t      i = -1,\n\t      j = 0,\n\t      merged,\n\t      array;\n\n\t  while (++i < n) j += arrays[i].length;\n\t  merged = new Array(j);\n\n\t  while (--n >= 0) {\n\t    array = arrays[n];\n\t    m = array.length;\n\t    while (--m >= 0) {\n\t      merged[--j] = array[m];\n\t    }\n\t  }\n\n\t  return merged;\n\t}\n\n\tfunction sum(array, f) {\n\t  var s = 0,\n\t      n = array.length,\n\t      a,\n\t      i = -1;\n\n\t  if (f == null) {\n\t    while (++i < n) if (a = +array[i]) s += a; // Note: zero and null are equivalent.\n\t  }\n\n\t  else {\n\t    while (++i < n) if (a = +f(array[i], i, array)) s += a;\n\t  }\n\n\t  return s;\n\t}\n\n\t// Adds floating point numbers with twice the normal precision.\n\t// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and\n\t// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)\n\t// 305–363 (1997).\n\t// Code adapted from GeographicLib by Charles F. F. Karney,\n\t// http://geographiclib.sourceforge.net/\n\n\tfunction adder() {\n\t  return new Adder;\n\t}\n\n\tfunction Adder() {\n\t  this.reset();\n\t}\n\n\tAdder.prototype = {\n\t  constructor: Adder,\n\t  reset: function() {\n\t    this.s = // rounded value\n\t    this.t = 0; // exact error\n\t  },\n\t  add: function(y) {\n\t    add(temp, y, this.t);\n\t    add(this, temp.s, this.s);\n\t    if (this.s) this.t += temp.t;\n\t    else this.s = temp.t;\n\t  },\n\t  valueOf: function() {\n\t    return this.s;\n\t  }\n\t};\n\n\tvar temp = new Adder;\n\n\tfunction add(adder, a, b) {\n\t  var x = adder.s = a + b,\n\t      bv = x - a,\n\t      av = x - bv;\n\t  adder.t = (a - av) + (b - bv);\n\t}\n\n\tvar epsilon = 1e-6;\n\tvar pi = Math.PI;\n\tvar halfPi = pi / 2;\n\tvar quarterPi = pi / 4;\n\tvar tau = pi * 2;\n\n\tvar degrees = 180 / pi;\n\tvar radians = pi / 180;\n\n\tvar abs = Math.abs;\n\tvar atan = Math.atan;\n\tvar atan2 = Math.atan2;\n\tvar cos = Math.cos;\n\tvar sin = Math.sin;\n\tvar sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };\n\tvar sqrt = Math.sqrt;\n\tfunction acos(x) {\n\t  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);\n\t}\n\n\tfunction asin(x) {\n\t  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);\n\t}\n\n\tfunction noop() {}\n\n\tfunction streamGeometry(geometry, stream) {\n\t  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {\n\t    streamGeometryType[geometry.type](geometry, stream);\n\t  }\n\t}\n\n\tvar streamObjectType = {\n\t  Feature: function(object, stream) {\n\t    streamGeometry(object.geometry, stream);\n\t  },\n\t  FeatureCollection: function(object, stream) {\n\t    var features = object.features, i = -1, n = features.length;\n\t    while (++i < n) streamGeometry(features[i].geometry, stream);\n\t  }\n\t};\n\n\tvar streamGeometryType = {\n\t  Sphere: function(object, stream) {\n\t    stream.sphere();\n\t  },\n\t  Point: function(object, stream) {\n\t    object = object.coordinates;\n\t    stream.point(object[0], object[1], object[2]);\n\t  },\n\t  MultiPoint: function(object, stream) {\n\t    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n\t    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);\n\t  },\n\t  LineString: function(object, stream) {\n\t    streamLine(object.coordinates, stream, 0);\n\t  },\n\t  MultiLineString: function(object, stream) {\n\t    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n\t    while (++i < n) streamLine(coordinates[i], stream, 0);\n\t  },\n\t  Polygon: function(object, stream) {\n\t    streamPolygon(object.coordinates, stream);\n\t  },\n\t  MultiPolygon: function(object, stream) {\n\t    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n\t    while (++i < n) streamPolygon(coordinates[i], stream);\n\t  },\n\t  GeometryCollection: function(object, stream) {\n\t    var geometries = object.geometries, i = -1, n = geometries.length;\n\t    while (++i < n) streamGeometry(geometries[i], stream);\n\t  }\n\t};\n\n\tfunction streamLine(coordinates, stream, closed) {\n\t  var i = -1, n = coordinates.length - closed, coordinate;\n\t  stream.lineStart();\n\t  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);\n\t  stream.lineEnd();\n\t}\n\n\tfunction streamPolygon(coordinates, stream) {\n\t  var i = -1, n = coordinates.length;\n\t  stream.polygonStart();\n\t  while (++i < n) streamLine(coordinates[i], stream, 1);\n\t  stream.polygonEnd();\n\t}\n\n\tfunction geoStream(object, stream) {\n\t  if (object && streamObjectType.hasOwnProperty(object.type)) {\n\t    streamObjectType[object.type](object, stream);\n\t  } else {\n\t    streamGeometry(object, stream);\n\t  }\n\t}\n\n\tvar areaRingSum = adder();\n\n\tvar areaSum = adder();\n\tvar lambda00;\n\tvar phi00;\n\tvar lambda0;\n\tvar cosPhi0;\n\tvar sinPhi0;\n\tvar areaStream = {\n\t  point: noop,\n\t  lineStart: noop,\n\t  lineEnd: noop,\n\t  polygonStart: function() {\n\t    areaRingSum.reset();\n\t    areaStream.lineStart = areaRingStart;\n\t    areaStream.lineEnd = areaRingEnd;\n\t  },\n\t  polygonEnd: function() {\n\t    var areaRing = +areaRingSum;\n\t    areaSum.add(areaRing < 0 ? tau + areaRing : areaRing);\n\t    this.lineStart = this.lineEnd = this.point = noop;\n\t  },\n\t  sphere: function() {\n\t    areaSum.add(tau);\n\t  }\n\t};\n\n\tfunction areaRingStart() {\n\t  areaStream.point = areaPointFirst;\n\t}\n\n\tfunction areaRingEnd() {\n\t  areaPoint(lambda00, phi00);\n\t}\n\n\tfunction areaPointFirst(lambda, phi) {\n\t  areaStream.point = areaPoint;\n\t  lambda00 = lambda, phi00 = phi;\n\t  lambda *= radians, phi *= radians;\n\t  lambda0 = lambda, cosPhi0 = cos(phi = phi / 2 + quarterPi), sinPhi0 = sin(phi);\n\t}\n\n\tfunction areaPoint(lambda, phi) {\n\t  lambda *= radians, phi *= radians;\n\t  phi = phi / 2 + quarterPi; // half the angular distance from south pole\n\n\t  // Spherical excess E for a spherical triangle with vertices: south pole,\n\t  // previous point, current point.  Uses a formula derived from Cagnoli’s\n\t  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).\n\t  var dLambda = lambda - lambda0,\n\t      sdLambda = dLambda >= 0 ? 1 : -1,\n\t      adLambda = sdLambda * dLambda,\n\t      cosPhi = cos(phi),\n\t      sinPhi = sin(phi),\n\t      k = sinPhi0 * sinPhi,\n\t      u = cosPhi0 * cosPhi + k * cos(adLambda),\n\t      v = k * sdLambda * sin(adLambda);\n\t  areaRingSum.add(atan2(v, u));\n\n\t  // Advance the previous points.\n\t  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;\n\t}\n\n\tfunction spherical(cartesian) {\n\t  return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];\n\t}\n\n\tfunction cartesian(spherical) {\n\t  var lambda = spherical[0], phi = spherical[1], cosPhi = cos(phi);\n\t  return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];\n\t}\n\n\tfunction cartesianDot(a, b) {\n\t  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n\t}\n\n\tfunction cartesianCross(a, b) {\n\t  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];\n\t}\n\n\t// TODO return a\n\tfunction cartesianAddInPlace(a, b) {\n\t  a[0] += b[0], a[1] += b[1], a[2] += b[2];\n\t}\n\n\tfunction cartesianScale(vector, k) {\n\t  return [vector[0] * k, vector[1] * k, vector[2] * k];\n\t}\n\n\t// TODO return d\n\tfunction cartesianNormalizeInPlace(d) {\n\t  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\n\t  d[0] /= l, d[1] /= l, d[2] /= l;\n\t}\n\n\tvar lambda0$1;\n\tvar phi0;\n\tvar lambda1;\n\tvar phi1;\n\tvar lambda2;\n\tvar lambda00$1;\n\tvar phi00$1;\n\tvar p0;\n\tvar deltaSum = adder();\n\tvar ranges;\n\tvar range$1;\n\tvar boundsStream = {\n\t  point: boundsPoint,\n\t  lineStart: boundsLineStart,\n\t  lineEnd: boundsLineEnd,\n\t  polygonStart: function() {\n\t    boundsStream.point = boundsRingPoint;\n\t    boundsStream.lineStart = boundsRingStart;\n\t    boundsStream.lineEnd = boundsRingEnd;\n\t    deltaSum.reset();\n\t    areaStream.polygonStart();\n\t  },\n\t  polygonEnd: function() {\n\t    areaStream.polygonEnd();\n\t    boundsStream.point = boundsPoint;\n\t    boundsStream.lineStart = boundsLineStart;\n\t    boundsStream.lineEnd = boundsLineEnd;\n\t    if (areaRingSum < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n\t    else if (deltaSum > epsilon) phi1 = 90;\n\t    else if (deltaSum < -epsilon) phi0 = -90;\n\t    range$1[0] = lambda0$1, range$1[1] = lambda1;\n\t  }\n\t};\n\n\tfunction boundsPoint(lambda, phi) {\n\t  ranges.push(range$1 = [lambda0$1 = lambda, lambda1 = lambda]);\n\t  if (phi < phi0) phi0 = phi;\n\t  if (phi > phi1) phi1 = phi;\n\t}\n\n\tfunction linePoint(lambda, phi) {\n\t  var p = cartesian([lambda * radians, phi * radians]);\n\t  if (p0) {\n\t    var normal = cartesianCross(p0, p),\n\t        equatorial = [normal[1], -normal[0], 0],\n\t        inflection = cartesianCross(equatorial, normal);\n\t    cartesianNormalizeInPlace(inflection);\n\t    inflection = spherical(inflection);\n\t    var delta = lambda - lambda2,\n\t        sign = delta > 0 ? 1 : -1,\n\t        lambdai = inflection[0] * degrees * sign,\n\t        phii,\n\t        antimeridian = abs(delta) > 180;\n\t    if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n\t      phii = inflection[1] * degrees;\n\t      if (phii > phi1) phi1 = phii;\n\t    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n\t      phii = -inflection[1] * degrees;\n\t      if (phii < phi0) phi0 = phii;\n\t    } else {\n\t      if (phi < phi0) phi0 = phi;\n\t      if (phi > phi1) phi1 = phi;\n\t    }\n\t    if (antimeridian) {\n\t      if (lambda < lambda2) {\n\t        if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;\n\t      } else {\n\t        if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;\n\t      }\n\t    } else {\n\t      if (lambda1 >= lambda0$1) {\n\t        if (lambda < lambda0$1) lambda0$1 = lambda;\n\t        if (lambda > lambda1) lambda1 = lambda;\n\t      } else {\n\t        if (lambda > lambda2) {\n\t          if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;\n\t        } else {\n\t          if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;\n\t        }\n\t      }\n\t    }\n\t  } else {\n\t    ranges.push(range$1 = [lambda0$1 = lambda, lambda1 = lambda]);\n\t  }\n\t  if (phi < phi0) phi0 = phi;\n\t  if (phi > phi1) phi1 = phi;\n\t  p0 = p, lambda2 = lambda;\n\t}\n\n\tfunction boundsLineStart() {\n\t  boundsStream.point = linePoint;\n\t}\n\n\tfunction boundsLineEnd() {\n\t  range$1[0] = lambda0$1, range$1[1] = lambda1;\n\t  boundsStream.point = boundsPoint;\n\t  p0 = null;\n\t}\n\n\tfunction boundsRingPoint(lambda, phi) {\n\t  if (p0) {\n\t    var delta = lambda - lambda2;\n\t    deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);\n\t  } else {\n\t    lambda00$1 = lambda, phi00$1 = phi;\n\t  }\n\t  areaStream.point(lambda, phi);\n\t  linePoint(lambda, phi);\n\t}\n\n\tfunction boundsRingStart() {\n\t  areaStream.lineStart();\n\t}\n\n\tfunction boundsRingEnd() {\n\t  boundsRingPoint(lambda00$1, phi00$1);\n\t  areaStream.lineEnd();\n\t  if (abs(deltaSum) > epsilon) lambda0$1 = -(lambda1 = 180);\n\t  range$1[0] = lambda0$1, range$1[1] = lambda1;\n\t  p0 = null;\n\t}\n\n\t// Finds the left-right distance between two longitudes.\n\t// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want\n\t// the distance between ±180° to be 360°.\n\tfunction angle(lambda0, lambda1) {\n\t  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;\n\t}\n\n\tvar W0;\n\tvar W1;\n\tvar X0;\n\tvar Y0;\n\tvar Z0;\n\tvar X1;\n\tvar Y1;\n\tvar Z1;\n\tvar X2;\n\tvar Y2;\n\tvar Z2;\n\tvar lambda00$2;\n\tvar phi00$2;\n\tvar x0;\n\tvar y0;\n\tvar z0;\n\t// previous point\n\n\tvar centroidStream = {\n\t  sphere: noop,\n\t  point: centroidPoint,\n\t  lineStart: centroidLineStart,\n\t  lineEnd: centroidLineEnd,\n\t  polygonStart: function() {\n\t    centroidStream.lineStart = centroidRingStart;\n\t    centroidStream.lineEnd = centroidRingEnd;\n\t  },\n\t  polygonEnd: function() {\n\t    centroidStream.lineStart = centroidLineStart;\n\t    centroidStream.lineEnd = centroidLineEnd;\n\t  }\n\t};\n\n\t// Arithmetic mean of Cartesian vectors.\n\tfunction centroidPoint(lambda, phi) {\n\t  lambda *= radians, phi *= radians;\n\t  var cosPhi = cos(phi);\n\t  centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));\n\t}\n\n\tfunction centroidPointCartesian(x, y, z) {\n\t  ++W0;\n\t  X0 += (x - X0) / W0;\n\t  Y0 += (y - Y0) / W0;\n\t  Z0 += (z - Z0) / W0;\n\t}\n\n\tfunction centroidLineStart() {\n\t  centroidStream.point = centroidLinePointFirst;\n\t}\n\n\tfunction centroidLinePointFirst(lambda, phi) {\n\t  lambda *= radians, phi *= radians;\n\t  var cosPhi = cos(phi);\n\t  x0 = cosPhi * cos(lambda);\n\t  y0 = cosPhi * sin(lambda);\n\t  z0 = sin(phi);\n\t  centroidStream.point = centroidLinePoint;\n\t  centroidPointCartesian(x0, y0, z0);\n\t}\n\n\tfunction centroidLinePoint(lambda, phi) {\n\t  lambda *= radians, phi *= radians;\n\t  var cosPhi = cos(phi),\n\t      x = cosPhi * cos(lambda),\n\t      y = cosPhi * sin(lambda),\n\t      z = sin(phi),\n\t      w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);\n\t  W1 += w;\n\t  X1 += w * (x0 + (x0 = x));\n\t  Y1 += w * (y0 + (y0 = y));\n\t  Z1 += w * (z0 + (z0 = z));\n\t  centroidPointCartesian(x0, y0, z0);\n\t}\n\n\tfunction centroidLineEnd() {\n\t  centroidStream.point = centroidPoint;\n\t}\n\n\t// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,\n\t// J. Applied Mechanics 42, 239 (1975).\n\tfunction centroidRingStart() {\n\t  centroidStream.point = centroidRingPointFirst;\n\t}\n\n\tfunction centroidRingEnd() {\n\t  centroidRingPoint(lambda00$2, phi00$2);\n\t  centroidStream.point = centroidPoint;\n\t}\n\n\tfunction centroidRingPointFirst(lambda, phi) {\n\t  lambda00$2 = lambda, phi00$2 = phi;\n\t  lambda *= radians, phi *= radians;\n\t  centroidStream.point = centroidRingPoint;\n\t  var cosPhi = cos(phi);\n\t  x0 = cosPhi * cos(lambda);\n\t  y0 = cosPhi * sin(lambda);\n\t  z0 = sin(phi);\n\t  centroidPointCartesian(x0, y0, z0);\n\t}\n\n\tfunction centroidRingPoint(lambda, phi) {\n\t  lambda *= radians, phi *= radians;\n\t  var cosPhi = cos(phi),\n\t      x = cosPhi * cos(lambda),\n\t      y = cosPhi * sin(lambda),\n\t      z = sin(phi),\n\t      cx = y0 * z - z0 * y,\n\t      cy = z0 * x - x0 * z,\n\t      cz = x0 * y - y0 * x,\n\t      m = sqrt(cx * cx + cy * cy + cz * cz),\n\t      w = asin(m), // line weight = angle\n\t      v = m && -w / m; // area weight multiplier\n\t  X2 += v * cx;\n\t  Y2 += v * cy;\n\t  Z2 += v * cz;\n\t  W1 += w;\n\t  X1 += w * (x0 + (x0 = x));\n\t  Y1 += w * (y0 + (y0 = y));\n\t  Z1 += w * (z0 + (z0 = z));\n\t  centroidPointCartesian(x0, y0, z0);\n\t}\n\n\tfunction compose(a, b) {\n\n\t  function compose(x, y) {\n\t    return x = a(x, y), b(x[0], x[1]);\n\t  }\n\n\t  if (a.invert && b.invert) compose.invert = function(x, y) {\n\t    return x = b.invert(x, y), x && a.invert(x[0], x[1]);\n\t  };\n\n\t  return compose;\n\t}\n\n\tfunction rotationIdentity(lambda, phi) {\n\t  return [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];\n\t}\n\n\trotationIdentity.invert = rotationIdentity;\n\n\tfunction rotateRadians(deltaLambda, deltaPhi, deltaGamma) {\n\t  return (deltaLambda %= tau) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))\n\t    : rotationLambda(deltaLambda))\n\t    : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)\n\t    : rotationIdentity);\n\t}\n\n\tfunction forwardRotationLambda(deltaLambda) {\n\t  return function(lambda, phi) {\n\t    return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];\n\t  };\n\t}\n\n\tfunction rotationLambda(deltaLambda) {\n\t  var rotation = forwardRotationLambda(deltaLambda);\n\t  rotation.invert = forwardRotationLambda(-deltaLambda);\n\t  return rotation;\n\t}\n\n\tfunction rotationPhiGamma(deltaPhi, deltaGamma) {\n\t  var cosDeltaPhi = cos(deltaPhi),\n\t      sinDeltaPhi = sin(deltaPhi),\n\t      cosDeltaGamma = cos(deltaGamma),\n\t      sinDeltaGamma = sin(deltaGamma);\n\n\t  function rotation(lambda, phi) {\n\t    var cosPhi = cos(phi),\n\t        x = cos(lambda) * cosPhi,\n\t        y = sin(lambda) * cosPhi,\n\t        z = sin(phi),\n\t        k = z * cosDeltaPhi + x * sinDeltaPhi;\n\t    return [\n\t      atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),\n\t      asin(k * cosDeltaGamma + y * sinDeltaGamma)\n\t    ];\n\t  }\n\n\t  rotation.invert = function(lambda, phi) {\n\t    var cosPhi = cos(phi),\n\t        x = cos(lambda) * cosPhi,\n\t        y = sin(lambda) * cosPhi,\n\t        z = sin(phi),\n\t        k = z * cosDeltaGamma - y * sinDeltaGamma;\n\t    return [\n\t      atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),\n\t      asin(k * cosDeltaPhi - x * sinDeltaPhi)\n\t    ];\n\t  };\n\n\t  return rotation;\n\t}\n\n\t// Generates a circle centered at [0°, 0°], with a given radius and precision.\n\tfunction circleStream(stream, radius, delta, direction, t0, t1) {\n\t  if (!delta) return;\n\t  var cosRadius = cos(radius),\n\t      sinRadius = sin(radius),\n\t      step = direction * delta;\n\t  if (t0 == null) {\n\t    t0 = radius + direction * tau;\n\t    t1 = radius - step / 2;\n\t  } else {\n\t    t0 = circleRadius(cosRadius, t0);\n\t    t1 = circleRadius(cosRadius, t1);\n\t    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau;\n\t  }\n\t  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {\n\t    point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);\n\t    stream.point(point[0], point[1]);\n\t  }\n\t}\n\n\t// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].\n\tfunction circleRadius(cosRadius, point) {\n\t  point = cartesian(point), point[0] -= cosRadius;\n\t  cartesianNormalizeInPlace(point);\n\t  var radius = acos(-point[1]);\n\t  return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;\n\t}\n\n\tfunction clipBuffer() {\n\t  var lines = [],\n\t      line;\n\t  return {\n\t    point: function(x, y) {\n\t      line.push([x, y]);\n\t    },\n\t    lineStart: function() {\n\t      lines.push(line = []);\n\t    },\n\t    lineEnd: noop,\n\t    rejoin: function() {\n\t      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));\n\t    },\n\t    result: function() {\n\t      var result = lines;\n\t      lines = [];\n\t      line = null;\n\t      return result;\n\t    }\n\t  };\n\t}\n\n\tfunction clipLine(a, b, x0, y0, x1, y1) {\n\t  var ax = a[0],\n\t      ay = a[1],\n\t      bx = b[0],\n\t      by = b[1],\n\t      t0 = 0,\n\t      t1 = 1,\n\t      dx = bx - ax,\n\t      dy = by - ay,\n\t      r;\n\n\t  r = x0 - ax;\n\t  if (!dx && r > 0) return;\n\t  r /= dx;\n\t  if (dx < 0) {\n\t    if (r < t0) return;\n\t    if (r < t1) t1 = r;\n\t  } else if (dx > 0) {\n\t    if (r > t1) return;\n\t    if (r > t0) t0 = r;\n\t  }\n\n\t  r = x1 - ax;\n\t  if (!dx && r < 0) return;\n\t  r /= dx;\n\t  if (dx < 0) {\n\t    if (r > t1) return;\n\t    if (r > t0) t0 = r;\n\t  } else if (dx > 0) {\n\t    if (r < t0) return;\n\t    if (r < t1) t1 = r;\n\t  }\n\n\t  r = y0 - ay;\n\t  if (!dy && r > 0) return;\n\t  r /= dy;\n\t  if (dy < 0) {\n\t    if (r < t0) return;\n\t    if (r < t1) t1 = r;\n\t  } else if (dy > 0) {\n\t    if (r > t1) return;\n\t    if (r > t0) t0 = r;\n\t  }\n\n\t  r = y1 - ay;\n\t  if (!dy && r < 0) return;\n\t  r /= dy;\n\t  if (dy < 0) {\n\t    if (r > t1) return;\n\t    if (r > t0) t0 = r;\n\t  } else if (dy > 0) {\n\t    if (r < t0) return;\n\t    if (r < t1) t1 = r;\n\t  }\n\n\t  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;\n\t  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;\n\t  return true;\n\t}\n\n\tfunction pointEqual(a, b) {\n\t  return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;\n\t}\n\n\tfunction Intersection(point, points, other, entry) {\n\t  this.x = point;\n\t  this.z = points;\n\t  this.o = other; // another intersection\n\t  this.e = entry; // is an entry?\n\t  this.v = false; // visited\n\t  this.n = this.p = null; // next & previous\n\t}\n\n\t// A generalized polygon clipping algorithm: given a polygon that has been cut\n\t// into its visible line segments, and rejoins the segments by interpolating\n\t// along the clip edge.\n\tfunction clipPolygon(segments, compareIntersection, startInside, interpolate, stream) {\n\t  var subject = [],\n\t      clip = [],\n\t      i,\n\t      n;\n\n\t  segments.forEach(function(segment) {\n\t    if ((n = segment.length - 1) <= 0) return;\n\t    var n, p0 = segment[0], p1 = segment[n], x;\n\n\t    // If the first and last points of a segment are coincident, then treat as a\n\t    // closed ring. TODO if all rings are closed, then the winding order of the\n\t    // exterior ring should be checked.\n\t    if (pointEqual(p0, p1)) {\n\t      stream.lineStart();\n\t      for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);\n\t      stream.lineEnd();\n\t      return;\n\t    }\n\n\t    subject.push(x = new Intersection(p0, segment, null, true));\n\t    clip.push(x.o = new Intersection(p0, null, x, false));\n\t    subject.push(x = new Intersection(p1, segment, null, false));\n\t    clip.push(x.o = new Intersection(p1, null, x, true));\n\t  });\n\n\t  if (!subject.length) return;\n\n\t  clip.sort(compareIntersection);\n\t  link(subject);\n\t  link(clip);\n\n\t  for (i = 0, n = clip.length; i < n; ++i) {\n\t    clip[i].e = startInside = !startInside;\n\t  }\n\n\t  var start = subject[0],\n\t      points,\n\t      point;\n\n\t  while (1) {\n\t    // Find first unvisited intersection.\n\t    var current = start,\n\t        isSubject = true;\n\t    while (current.v) if ((current = current.n) === start) return;\n\t    points = current.z;\n\t    stream.lineStart();\n\t    do {\n\t      current.v = current.o.v = true;\n\t      if (current.e) {\n\t        if (isSubject) {\n\t          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);\n\t        } else {\n\t          interpolate(current.x, current.n.x, 1, stream);\n\t        }\n\t        current = current.n;\n\t      } else {\n\t        if (isSubject) {\n\t          points = current.p.z;\n\t          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);\n\t        } else {\n\t          interpolate(current.x, current.p.x, -1, stream);\n\t        }\n\t        current = current.p;\n\t      }\n\t      current = current.o;\n\t      points = current.z;\n\t      isSubject = !isSubject;\n\t    } while (!current.v);\n\t    stream.lineEnd();\n\t  }\n\t}\n\n\tfunction link(array) {\n\t  if (!(n = array.length)) return;\n\t  var n,\n\t      i = 0,\n\t      a = array[0],\n\t      b;\n\t  while (++i < n) {\n\t    a.n = b = array[i];\n\t    b.p = a;\n\t    a = b;\n\t  }\n\t  a.n = b = array[0];\n\t  b.p = a;\n\t}\n\n\tvar clipMax = 1e9;\n\tvar clipMin = -clipMax;\n\t// TODO Use d3-polygon’s polygonContains here for the ring check?\n\t// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?\n\n\tfunction clipExtent(x0, y0, x1, y1) {\n\n\t  function visible(x, y) {\n\t    return x0 <= x && x <= x1 && y0 <= y && y <= y1;\n\t  }\n\n\t  function interpolate(from, to, direction, stream) {\n\t    var a = 0, a1 = 0;\n\t    if (from == null\n\t        || (a = corner(from, direction)) !== (a1 = corner(to, direction))\n\t        || comparePoint(from, to) < 0 ^ direction > 0) {\n\t      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);\n\t      while ((a = (a + direction + 4) % 4) !== a1);\n\t    } else {\n\t      stream.point(to[0], to[1]);\n\t    }\n\t  }\n\n\t  function corner(p, direction) {\n\t    return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3\n\t        : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1\n\t        : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0\n\t        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon\n\t  }\n\n\t  function compareIntersection(a, b) {\n\t    return comparePoint(a.x, b.x);\n\t  }\n\n\t  function comparePoint(a, b) {\n\t    var ca = corner(a, 1),\n\t        cb = corner(b, 1);\n\t    return ca !== cb ? ca - cb\n\t        : ca === 0 ? b[1] - a[1]\n\t        : ca === 1 ? a[0] - b[0]\n\t        : ca === 2 ? a[1] - b[1]\n\t        : b[0] - a[0];\n\t  }\n\n\t  return function(stream) {\n\t    var activeStream = stream,\n\t        bufferStream = clipBuffer(),\n\t        segments,\n\t        polygon,\n\t        ring,\n\t        x__, y__, v__, // first point\n\t        x_, y_, v_, // previous point\n\t        first,\n\t        clean;\n\n\t    var clipStream = {\n\t      point: point,\n\t      lineStart: lineStart,\n\t      lineEnd: lineEnd,\n\t      polygonStart: polygonStart,\n\t      polygonEnd: polygonEnd\n\t    };\n\n\t    function point(x, y) {\n\t      if (visible(x, y)) activeStream.point(x, y);\n\t    }\n\n\t    function polygonInside() {\n\t      var winding = 0;\n\n\t      for (var i = 0, n = polygon.length; i < n; ++i) {\n\t        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {\n\t          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];\n\t          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }\n\t          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }\n\t        }\n\t      }\n\n\t      return winding;\n\t    }\n\n\t    // Buffer geometry within a polygon and then clip it en masse.\n\t    function polygonStart() {\n\t      activeStream = bufferStream, segments = [], polygon = [], clean = true;\n\t    }\n\n\t    function polygonEnd() {\n\t      var startInside = polygonInside(),\n\t          cleanInside = clean && startInside,\n\t          visible = (segments = merge(segments)).length;\n\t      if (cleanInside || visible) {\n\t        stream.polygonStart();\n\t        if (cleanInside) {\n\t          stream.lineStart();\n\t          interpolate(null, null, 1, stream);\n\t          stream.lineEnd();\n\t        }\n\t        if (visible) {\n\t          clipPolygon(segments, compareIntersection, startInside, interpolate, stream);\n\t        }\n\t        stream.polygonEnd();\n\t      }\n\t      activeStream = stream, segments = polygon = ring = null;\n\t    }\n\n\t    function lineStart() {\n\t      clipStream.point = linePoint;\n\t      if (polygon) polygon.push(ring = []);\n\t      first = true;\n\t      v_ = false;\n\t      x_ = y_ = NaN;\n\t    }\n\n\t    // TODO rather than special-case polygons, simply handle them separately.\n\t    // Ideally, coincident intersection points should be jittered to avoid\n\t    // clipping issues.\n\t    function lineEnd() {\n\t      if (segments) {\n\t        linePoint(x__, y__);\n\t        if (v__ && v_) bufferStream.rejoin();\n\t        segments.push(bufferStream.result());\n\t      }\n\t      clipStream.point = point;\n\t      if (v_) activeStream.lineEnd();\n\t    }\n\n\t    function linePoint(x, y) {\n\t      var v = visible(x, y);\n\t      if (polygon) ring.push([x, y]);\n\t      if (first) {\n\t        x__ = x, y__ = y, v__ = v;\n\t        first = false;\n\t        if (v) {\n\t          activeStream.lineStart();\n\t          activeStream.point(x, y);\n\t        }\n\t      } else {\n\t        if (v && v_) activeStream.point(x, y);\n\t        else {\n\t          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],\n\t              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];\n\t          if (clipLine(a, b, x0, y0, x1, y1)) {\n\t            if (!v_) {\n\t              activeStream.lineStart();\n\t              activeStream.point(a[0], a[1]);\n\t            }\n\t            activeStream.point(b[0], b[1]);\n\t            if (!v) activeStream.lineEnd();\n\t            clean = false;\n\t          } else if (v) {\n\t            activeStream.lineStart();\n\t            activeStream.point(x, y);\n\t            clean = false;\n\t          }\n\t        }\n\t      }\n\t      x_ = x, y_ = y, v_ = v;\n\t    }\n\n\t    return clipStream;\n\t  };\n\t}\n\n\tvar sum$1 = adder();\n\n\tfunction polygonContains(polygon, point) {\n\t  var lambda = point[0],\n\t      phi = point[1],\n\t      normal = [sin(lambda), -cos(lambda), 0],\n\t      angle = 0,\n\t      winding = 0;\n\n\t  sum$1.reset();\n\n\t  for (var i = 0, n = polygon.length; i < n; ++i) {\n\t    if (!(m = (ring = polygon[i]).length)) continue;\n\t    var ring,\n\t        m,\n\t        point0 = ring[m - 1],\n\t        lambda0 = point0[0],\n\t        phi0 = point0[1] / 2 + quarterPi,\n\t        sinPhi0 = sin(phi0),\n\t        cosPhi0 = cos(phi0);\n\n\t    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {\n\t      var point1 = ring[j],\n\t          lambda1 = point1[0],\n\t          phi1 = point1[1] / 2 + quarterPi,\n\t          sinPhi1 = sin(phi1),\n\t          cosPhi1 = cos(phi1),\n\t          delta = lambda1 - lambda0,\n\t          sign = delta >= 0 ? 1 : -1,\n\t          absDelta = sign * delta,\n\t          antimeridian = absDelta > pi,\n\t          k = sinPhi0 * sinPhi1;\n\n\t      sum$1.add(atan2(k * sign * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));\n\t      angle += antimeridian ? delta + sign * tau : delta;\n\n\t      // Are the longitudes either side of the point’s meridian (lambda),\n\t      // and are the latitudes smaller than the parallel (phi)?\n\t      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {\n\t        var arc = cartesianCross(cartesian(point0), cartesian(point1));\n\t        cartesianNormalizeInPlace(arc);\n\t        var intersection = cartesianCross(normal, arc);\n\t        cartesianNormalizeInPlace(intersection);\n\t        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);\n\t        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {\n\t          winding += antimeridian ^ delta >= 0 ? 1 : -1;\n\t        }\n\t      }\n\t    }\n\t  }\n\n\t  // First, determine whether the South pole is inside or outside:\n\t  //\n\t  // It is inside if:\n\t  // * the polygon winds around it in a clockwise direction.\n\t  // * the polygon does not (cumulatively) wind around it, but has a negative\n\t  //   (counter-clockwise) area.\n\t  //\n\t  // Second, count the (signed) number of times a segment crosses a lambda\n\t  // from the point to the South pole.  If it is zero, then the point is the\n\t  // same side as the South pole.\n\n\t  return (angle < -epsilon || angle < epsilon && sum$1 < -epsilon) ^ (winding & 1);\n\t}\n\n\tvar lengthSum = adder();\n\tvar lambda0$2;\n\tvar sinPhi0$1;\n\tvar cosPhi0$1;\n\tvar lengthStream = {\n\t  sphere: noop,\n\t  point: noop,\n\t  lineStart: lengthLineStart,\n\t  lineEnd: noop,\n\t  polygonStart: noop,\n\t  polygonEnd: noop\n\t};\n\n\tfunction lengthLineStart() {\n\t  lengthStream.point = lengthPointFirst;\n\t  lengthStream.lineEnd = lengthLineEnd;\n\t}\n\n\tfunction lengthLineEnd() {\n\t  lengthStream.point = lengthStream.lineEnd = noop;\n\t}\n\n\tfunction lengthPointFirst(lambda, phi) {\n\t  lambda *= radians, phi *= radians;\n\t  lambda0$2 = lambda, sinPhi0$1 = sin(phi), cosPhi0$1 = cos(phi);\n\t  lengthStream.point = lengthPoint;\n\t}\n\n\tfunction lengthPoint(lambda, phi) {\n\t  lambda *= radians, phi *= radians;\n\t  var sinPhi = sin(phi),\n\t      cosPhi = cos(phi),\n\t      delta = abs(lambda - lambda0$2),\n\t      cosDelta = cos(delta),\n\t      sinDelta = sin(delta),\n\t      x = cosPhi * sinDelta,\n\t      y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta,\n\t      z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;\n\t  lengthSum.add(atan2(sqrt(x * x + y * y), z));\n\t  lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;\n\t}\n\n\tfunction identity$1(x) {\n\t  return x;\n\t}\n\n\tvar areaSum$1 = adder();\n\tvar areaRingSum$1 = adder();\n\tvar x00;\n\tvar y00;\n\tvar x0$1;\n\tvar y0$1;\n\tvar areaStream$1 = {\n\t  point: noop,\n\t  lineStart: noop,\n\t  lineEnd: noop,\n\t  polygonStart: function() {\n\t    areaStream$1.lineStart = areaRingStart$1;\n\t    areaStream$1.lineEnd = areaRingEnd$1;\n\t  },\n\t  polygonEnd: function() {\n\t    areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop;\n\t    areaSum$1.add(abs(areaRingSum$1));\n\t    areaRingSum$1.reset();\n\t  },\n\t  result: function() {\n\t    var area = areaSum$1 / 2;\n\t    areaSum$1.reset();\n\t    return area;\n\t  }\n\t};\n\n\tfunction areaRingStart$1() {\n\t  areaStream$1.point = areaPointFirst$1;\n\t}\n\n\tfunction areaPointFirst$1(x, y) {\n\t  areaStream$1.point = areaPoint$1;\n\t  x00 = x0$1 = x, y00 = y0$1 = y;\n\t}\n\n\tfunction areaPoint$1(x, y) {\n\t  areaRingSum$1.add(y0$1 * x - x0$1 * y);\n\t  x0$1 = x, y0$1 = y;\n\t}\n\n\tfunction areaRingEnd$1() {\n\t  areaPoint$1(x00, y00);\n\t}\n\n\tvar x0$2 = Infinity;\n\tvar y0$2 = x0$2;\n\tvar x1 = -x0$2;\n\tvar y1 = x1;\n\tvar boundsStream$1 = {\n\t  point: boundsPoint$1,\n\t  lineStart: noop,\n\t  lineEnd: noop,\n\t  polygonStart: noop,\n\t  polygonEnd: noop,\n\t  result: function() {\n\t    var bounds = [[x0$2, y0$2], [x1, y1]];\n\t    x1 = y1 = -(y0$2 = x0$2 = Infinity);\n\t    return bounds;\n\t  }\n\t};\n\n\tfunction boundsPoint$1(x, y) {\n\t  if (x < x0$2) x0$2 = x;\n\t  if (x > x1) x1 = x;\n\t  if (y < y0$2) y0$2 = y;\n\t  if (y > y1) y1 = y;\n\t}\n\n\tvar X0$1 = 0;\n\tvar Y0$1 = 0;\n\tvar Z0$1 = 0;\n\tvar X1$1 = 0;\n\tvar Y1$1 = 0;\n\tvar Z1$1 = 0;\n\tvar X2$1 = 0;\n\tvar Y2$1 = 0;\n\tvar Z2$1 = 0;\n\tvar x00$1;\n\tvar y00$1;\n\tvar x0$3;\n\tvar y0$3;\n\tvar centroidStream$1 = {\n\t  point: centroidPoint$1,\n\t  lineStart: centroidLineStart$1,\n\t  lineEnd: centroidLineEnd$1,\n\t  polygonStart: function() {\n\t    centroidStream$1.lineStart = centroidRingStart$1;\n\t    centroidStream$1.lineEnd = centroidRingEnd$1;\n\t  },\n\t  polygonEnd: function() {\n\t    centroidStream$1.point = centroidPoint$1;\n\t    centroidStream$1.lineStart = centroidLineStart$1;\n\t    centroidStream$1.lineEnd = centroidLineEnd$1;\n\t  },\n\t  result: function() {\n\t    var centroid = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1]\n\t        : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1]\n\t        : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1]\n\t        : [NaN, NaN];\n\t    X0$1 = Y0$1 = Z0$1 =\n\t    X1$1 = Y1$1 = Z1$1 =\n\t    X2$1 = Y2$1 = Z2$1 = 0;\n\t    return centroid;\n\t  }\n\t};\n\n\tfunction centroidPoint$1(x, y) {\n\t  X0$1 += x;\n\t  Y0$1 += y;\n\t  ++Z0$1;\n\t}\n\n\tfunction centroidLineStart$1() {\n\t  centroidStream$1.point = centroidPointFirstLine;\n\t}\n\n\tfunction centroidPointFirstLine(x, y) {\n\t  centroidStream$1.point = centroidPointLine;\n\t  centroidPoint$1(x0$3 = x, y0$3 = y);\n\t}\n\n\tfunction centroidPointLine(x, y) {\n\t  var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);\n\t  X1$1 += z * (x0$3 + x) / 2;\n\t  Y1$1 += z * (y0$3 + y) / 2;\n\t  Z1$1 += z;\n\t  centroidPoint$1(x0$3 = x, y0$3 = y);\n\t}\n\n\tfunction centroidLineEnd$1() {\n\t  centroidStream$1.point = centroidPoint$1;\n\t}\n\n\tfunction centroidRingStart$1() {\n\t  centroidStream$1.point = centroidPointFirstRing;\n\t}\n\n\tfunction centroidRingEnd$1() {\n\t  centroidPointRing(x00$1, y00$1);\n\t}\n\n\tfunction centroidPointFirstRing(x, y) {\n\t  centroidStream$1.point = centroidPointRing;\n\t  centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);\n\t}\n\n\tfunction centroidPointRing(x, y) {\n\t  var dx = x - x0$3,\n\t      dy = y - y0$3,\n\t      z = sqrt(dx * dx + dy * dy);\n\n\t  X1$1 += z * (x0$3 + x) / 2;\n\t  Y1$1 += z * (y0$3 + y) / 2;\n\t  Z1$1 += z;\n\n\t  z = y0$3 * x - x0$3 * y;\n\t  X2$1 += z * (x0$3 + x);\n\t  Y2$1 += z * (y0$3 + y);\n\t  Z2$1 += z * 3;\n\t  centroidPoint$1(x0$3 = x, y0$3 = y);\n\t}\n\n\tfunction PathContext(context) {\n\t  this._context = context;\n\t}\n\n\tPathContext.prototype = {\n\t  _radius: 4.5,\n\t  pointRadius: function(_) {\n\t    return this._radius = _, this;\n\t  },\n\t  polygonStart: function() {\n\t    this._line = 0;\n\t  },\n\t  polygonEnd: function() {\n\t    this._line = NaN;\n\t  },\n\t  lineStart: function() {\n\t    this._point = 0;\n\t  },\n\t  lineEnd: function() {\n\t    if (this._line === 0) this._context.closePath();\n\t    this._point = NaN;\n\t  },\n\t  point: function(x, y) {\n\t    switch (this._point) {\n\t      case 0: {\n\t        this._context.moveTo(x, y);\n\t        this._point = 1;\n\t        break;\n\t      }\n\t      case 1: {\n\t        this._context.lineTo(x, y);\n\t        break;\n\t      }\n\t      default: {\n\t        this._context.moveTo(x + this._radius, y);\n\t        this._context.arc(x, y, this._radius, 0, tau);\n\t        break;\n\t      }\n\t    }\n\t  },\n\t  result: noop\n\t};\n\n\tvar lengthSum$1 = adder();\n\tvar lengthRing;\n\tvar x00$2;\n\tvar y00$2;\n\tvar x0$4;\n\tvar y0$4;\n\tvar lengthStream$1 = {\n\t  point: noop,\n\t  lineStart: function() {\n\t    lengthStream$1.point = lengthPointFirst$1;\n\t  },\n\t  lineEnd: function() {\n\t    if (lengthRing) lengthPoint$1(x00$2, y00$2);\n\t    lengthStream$1.point = noop;\n\t  },\n\t  polygonStart: function() {\n\t    lengthRing = true;\n\t  },\n\t  polygonEnd: function() {\n\t    lengthRing = null;\n\t  },\n\t  result: function() {\n\t    var length = +lengthSum$1;\n\t    lengthSum$1.reset();\n\t    return length;\n\t  }\n\t};\n\n\tfunction lengthPointFirst$1(x, y) {\n\t  lengthStream$1.point = lengthPoint$1;\n\t  x00$2 = x0$4 = x, y00$2 = y0$4 = y;\n\t}\n\n\tfunction lengthPoint$1(x, y) {\n\t  x0$4 -= x, y0$4 -= y;\n\t  lengthSum$1.add(sqrt(x0$4 * x0$4 + y0$4 * y0$4));\n\t  x0$4 = x, y0$4 = y;\n\t}\n\n\tfunction PathString() {\n\t  this._string = [];\n\t}\n\n\tPathString.prototype = {\n\t  _circle: circle$1(4.5),\n\t  pointRadius: function(_) {\n\t    return this._circle = circle$1(_), this;\n\t  },\n\t  polygonStart: function() {\n\t    this._line = 0;\n\t  },\n\t  polygonEnd: function() {\n\t    this._line = NaN;\n\t  },\n\t  lineStart: function() {\n\t    this._point = 0;\n\t  },\n\t  lineEnd: function() {\n\t    if (this._line === 0) this._string.push(\"Z\");\n\t    this._point = NaN;\n\t  },\n\t  point: function(x, y) {\n\t    switch (this._point) {\n\t      case 0: {\n\t        this._string.push(\"M\", x, \",\", y);\n\t        this._point = 1;\n\t        break;\n\t      }\n\t      case 1: {\n\t        this._string.push(\"L\", x, \",\", y);\n\t        break;\n\t      }\n\t      default: {\n\t        this._string.push(\"M\", x, \",\", y, this._circle);\n\t        break;\n\t      }\n\t    }\n\t  },\n\t  result: function() {\n\t    if (this._string.length) {\n\t      var result = this._string.join(\"\");\n\t      this._string = [];\n\t      return result;\n\t    }\n\t  }\n\t};\n\n\tfunction circle$1(radius) {\n\t  return \"m0,\" + radius\n\t      + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + -2 * radius\n\t      + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + 2 * radius\n\t      + \"z\";\n\t}\n\n\tfunction geoPath(projection, context) {\n\t  var pointRadius = 4.5,\n\t      projectionStream,\n\t      contextStream;\n\n\t  function path(object) {\n\t    if (object) {\n\t      if (typeof pointRadius === \"function\") contextStream.pointRadius(+pointRadius.apply(this, arguments));\n\t      geoStream(object, projectionStream(contextStream));\n\t    }\n\t    return contextStream.result();\n\t  }\n\n\t  path.area = function(object) {\n\t    geoStream(object, projectionStream(areaStream$1));\n\t    return areaStream$1.result();\n\t  };\n\n\t  path.measure = function(object) {\n\t    geoStream(object, projectionStream(lengthStream$1));\n\t    return lengthStream$1.result();\n\t  };\n\n\t  path.bounds = function(object) {\n\t    geoStream(object, projectionStream(boundsStream$1));\n\t    return boundsStream$1.result();\n\t  };\n\n\t  path.centroid = function(object) {\n\t    geoStream(object, projectionStream(centroidStream$1));\n\t    return centroidStream$1.result();\n\t  };\n\n\t  path.projection = function(_) {\n\t    return arguments.length ? (projectionStream = _ == null ? (projection = null, identity$1) : (projection = _).stream, path) : projection;\n\t  };\n\n\t  path.context = function(_) {\n\t    if (!arguments.length) return context;\n\t    contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);\n\t    if (typeof pointRadius !== \"function\") contextStream.pointRadius(pointRadius);\n\t    return path;\n\t  };\n\n\t  path.pointRadius = function(_) {\n\t    if (!arguments.length) return pointRadius;\n\t    pointRadius = typeof _ === \"function\" ? _ : (contextStream.pointRadius(+_), +_);\n\t    return path;\n\t  };\n\n\t  return path.projection(projection).context(context);\n\t}\n\n\tfunction clip(pointVisible, clipLine, interpolate, start) {\n\t  return function(rotate, sink) {\n\t    var line = clipLine(sink),\n\t        rotatedStart = rotate.invert(start[0], start[1]),\n\t        ringBuffer = clipBuffer(),\n\t        ringSink = clipLine(ringBuffer),\n\t        polygonStarted = false,\n\t        polygon,\n\t        segments,\n\t        ring;\n\n\t    var clip = {\n\t      point: point,\n\t      lineStart: lineStart,\n\t      lineEnd: lineEnd,\n\t      polygonStart: function() {\n\t        clip.point = pointRing;\n\t        clip.lineStart = ringStart;\n\t        clip.lineEnd = ringEnd;\n\t        segments = [];\n\t        polygon = [];\n\t      },\n\t      polygonEnd: function() {\n\t        clip.point = point;\n\t        clip.lineStart = lineStart;\n\t        clip.lineEnd = lineEnd;\n\t        segments = merge(segments);\n\t        var startInside = polygonContains(polygon, rotatedStart);\n\t        if (segments.length) {\n\t          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n\t          clipPolygon(segments, compareIntersection, startInside, interpolate, sink);\n\t        } else if (startInside) {\n\t          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n\t          sink.lineStart();\n\t          interpolate(null, null, 1, sink);\n\t          sink.lineEnd();\n\t        }\n\t        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;\n\t        segments = polygon = null;\n\t      },\n\t      sphere: function() {\n\t        sink.polygonStart();\n\t        sink.lineStart();\n\t        interpolate(null, null, 1, sink);\n\t        sink.lineEnd();\n\t        sink.polygonEnd();\n\t      }\n\t    };\n\n\t    function point(lambda, phi) {\n\t      var point = rotate(lambda, phi);\n\t      if (pointVisible(lambda = point[0], phi = point[1])) sink.point(lambda, phi);\n\t    }\n\n\t    function pointLine(lambda, phi) {\n\t      var point = rotate(lambda, phi);\n\t      line.point(point[0], point[1]);\n\t    }\n\n\t    function lineStart() {\n\t      clip.point = pointLine;\n\t      line.lineStart();\n\t    }\n\n\t    function lineEnd() {\n\t      clip.point = point;\n\t      line.lineEnd();\n\t    }\n\n\t    function pointRing(lambda, phi) {\n\t      ring.push([lambda, phi]);\n\t      var point = rotate(lambda, phi);\n\t      ringSink.point(point[0], point[1]);\n\t    }\n\n\t    function ringStart() {\n\t      ringSink.lineStart();\n\t      ring = [];\n\t    }\n\n\t    function ringEnd() {\n\t      pointRing(ring[0][0], ring[0][1]);\n\t      ringSink.lineEnd();\n\n\t      var clean = ringSink.clean(),\n\t          ringSegments = ringBuffer.result(),\n\t          i, n = ringSegments.length, m,\n\t          segment,\n\t          point;\n\n\t      ring.pop();\n\t      polygon.push(ring);\n\t      ring = null;\n\n\t      if (!n) return;\n\n\t      // No intersections.\n\t      if (clean & 1) {\n\t        segment = ringSegments[0];\n\t        if ((m = segment.length - 1) > 0) {\n\t          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n\t          sink.lineStart();\n\t          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);\n\t          sink.lineEnd();\n\t        }\n\t        return;\n\t      }\n\n\t      // Rejoin connected segments.\n\t      // TODO reuse ringBuffer.rejoin()?\n\t      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n\n\t      segments.push(ringSegments.filter(validSegment));\n\t    }\n\n\t    return clip;\n\t  };\n\t}\n\n\tfunction validSegment(segment) {\n\t  return segment.length > 1;\n\t}\n\n\t// Intersections are sorted along the clip edge. For both antimeridian cutting\n\t// and circle clipping, the same comparison is used.\n\tfunction compareIntersection(a, b) {\n\t  return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1])\n\t       - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);\n\t}\n\n\tvar clipAntimeridian = clip(\n\t  function() { return true; },\n\t  clipAntimeridianLine,\n\t  clipAntimeridianInterpolate,\n\t  [-pi, -halfPi]\n\t);\n\n\t// Takes a line and cuts into visible segments. Return values: 0 - there were\n\t// intersections or the line was empty; 1 - no intersections; 2 - there were\n\t// intersections, and the first and last segments should be rejoined.\n\tfunction clipAntimeridianLine(stream) {\n\t  var lambda0 = NaN,\n\t      phi0 = NaN,\n\t      sign0 = NaN,\n\t      clean; // no intersections\n\n\t  return {\n\t    lineStart: function() {\n\t      stream.lineStart();\n\t      clean = 1;\n\t    },\n\t    point: function(lambda1, phi1) {\n\t      var sign1 = lambda1 > 0 ? pi : -pi,\n\t          delta = abs(lambda1 - lambda0);\n\t      if (abs(delta - pi) < epsilon) { // line crosses a pole\n\t        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);\n\t        stream.point(sign0, phi0);\n\t        stream.lineEnd();\n\t        stream.lineStart();\n\t        stream.point(sign1, phi0);\n\t        stream.point(lambda1, phi0);\n\t        clean = 0;\n\t      } else if (sign0 !== sign1 && delta >= pi) { // line crosses antimeridian\n\t        if (abs(lambda0 - sign0) < epsilon) lambda0 -= sign0 * epsilon; // handle degeneracies\n\t        if (abs(lambda1 - sign1) < epsilon) lambda1 -= sign1 * epsilon;\n\t        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);\n\t        stream.point(sign0, phi0);\n\t        stream.lineEnd();\n\t        stream.lineStart();\n\t        stream.point(sign1, phi0);\n\t        clean = 0;\n\t      }\n\t      stream.point(lambda0 = lambda1, phi0 = phi1);\n\t      sign0 = sign1;\n\t    },\n\t    lineEnd: function() {\n\t      stream.lineEnd();\n\t      lambda0 = phi0 = NaN;\n\t    },\n\t    clean: function() {\n\t      return 2 - clean; // if intersections, rejoin first and last segments\n\t    }\n\t  };\n\t}\n\n\tfunction clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {\n\t  var cosPhi0,\n\t      cosPhi1,\n\t      sinLambda0Lambda1 = sin(lambda0 - lambda1);\n\t  return abs(sinLambda0Lambda1) > epsilon\n\t      ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1)\n\t          - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0))\n\t          / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))\n\t      : (phi0 + phi1) / 2;\n\t}\n\n\tfunction clipAntimeridianInterpolate(from, to, direction, stream) {\n\t  var phi;\n\t  if (from == null) {\n\t    phi = direction * halfPi;\n\t    stream.point(-pi, phi);\n\t    stream.point(0, phi);\n\t    stream.point(pi, phi);\n\t    stream.point(pi, 0);\n\t    stream.point(pi, -phi);\n\t    stream.point(0, -phi);\n\t    stream.point(-pi, -phi);\n\t    stream.point(-pi, 0);\n\t    stream.point(-pi, phi);\n\t  } else if (abs(from[0] - to[0]) > epsilon) {\n\t    var lambda = from[0] < to[0] ? pi : -pi;\n\t    phi = direction * lambda / 2;\n\t    stream.point(-lambda, phi);\n\t    stream.point(0, phi);\n\t    stream.point(lambda, phi);\n\t  } else {\n\t    stream.point(to[0], to[1]);\n\t  }\n\t}\n\n\tfunction clipCircle(radius, delta) {\n\t  var cr = cos(radius),\n\t      smallRadius = cr > 0,\n\t      notHemisphere = abs(cr) > epsilon; // TODO optimise for this common case\n\n\t  function interpolate(from, to, direction, stream) {\n\t    circleStream(stream, radius, delta, direction, from, to);\n\t  }\n\n\t  function visible(lambda, phi) {\n\t    return cos(lambda) * cos(phi) > cr;\n\t  }\n\n\t  // Takes a line and cuts into visible segments. Return values used for polygon\n\t  // clipping: 0 - there were intersections or the line was empty; 1 - no\n\t  // intersections 2 - there were intersections, and the first and last segments\n\t  // should be rejoined.\n\t  function clipLine(stream) {\n\t    var point0, // previous point\n\t        c0, // code for previous point\n\t        v0, // visibility of previous point\n\t        v00, // visibility of first point\n\t        clean; // no intersections\n\t    return {\n\t      lineStart: function() {\n\t        v00 = v0 = false;\n\t        clean = 1;\n\t      },\n\t      point: function(lambda, phi) {\n\t        var point1 = [lambda, phi],\n\t            point2,\n\t            v = visible(lambda, phi),\n\t            c = smallRadius\n\t              ? v ? 0 : code(lambda, phi)\n\t              : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;\n\t        if (!point0 && (v00 = v0 = v)) stream.lineStart();\n\t        // Handle degeneracies.\n\t        // TODO ignore if not clipping polygons.\n\t        if (v !== v0) {\n\t          point2 = intersect(point0, point1);\n\t          if (pointEqual(point0, point2) || pointEqual(point1, point2)) {\n\t            point1[0] += epsilon;\n\t            point1[1] += epsilon;\n\t            v = visible(point1[0], point1[1]);\n\t          }\n\t        }\n\t        if (v !== v0) {\n\t          clean = 0;\n\t          if (v) {\n\t            // outside going in\n\t            stream.lineStart();\n\t            point2 = intersect(point1, point0);\n\t            stream.point(point2[0], point2[1]);\n\t          } else {\n\t            // inside going out\n\t            point2 = intersect(point0, point1);\n\t            stream.point(point2[0], point2[1]);\n\t            stream.lineEnd();\n\t          }\n\t          point0 = point2;\n\t        } else if (notHemisphere && point0 && smallRadius ^ v) {\n\t          var t;\n\t          // If the codes for two points are different, or are both zero,\n\t          // and there this segment intersects with the small circle.\n\t          if (!(c & c0) && (t = intersect(point1, point0, true))) {\n\t            clean = 0;\n\t            if (smallRadius) {\n\t              stream.lineStart();\n\t              stream.point(t[0][0], t[0][1]);\n\t              stream.point(t[1][0], t[1][1]);\n\t              stream.lineEnd();\n\t            } else {\n\t              stream.point(t[1][0], t[1][1]);\n\t              stream.lineEnd();\n\t              stream.lineStart();\n\t              stream.point(t[0][0], t[0][1]);\n\t            }\n\t          }\n\t        }\n\t        if (v && (!point0 || !pointEqual(point0, point1))) {\n\t          stream.point(point1[0], point1[1]);\n\t        }\n\t        point0 = point1, v0 = v, c0 = c;\n\t      },\n\t      lineEnd: function() {\n\t        if (v0) stream.lineEnd();\n\t        point0 = null;\n\t      },\n\t      // Rejoin first and last segments if there were intersections and the first\n\t      // and last points were visible.\n\t      clean: function() {\n\t        return clean | ((v00 && v0) << 1);\n\t      }\n\t    };\n\t  }\n\n\t  // Intersects the great circle between a and b with the clip circle.\n\t  function intersect(a, b, two) {\n\t    var pa = cartesian(a),\n\t        pb = cartesian(b);\n\n\t    // We have two planes, n1.p = d1 and n2.p = d2.\n\t    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).\n\t    var n1 = [1, 0, 0], // normal\n\t        n2 = cartesianCross(pa, pb),\n\t        n2n2 = cartesianDot(n2, n2),\n\t        n1n2 = n2[0], // cartesianDot(n1, n2),\n\t        determinant = n2n2 - n1n2 * n1n2;\n\n\t    // Two polar points.\n\t    if (!determinant) return !two && a;\n\n\t    var c1 =  cr * n2n2 / determinant,\n\t        c2 = -cr * n1n2 / determinant,\n\t        n1xn2 = cartesianCross(n1, n2),\n\t        A = cartesianScale(n1, c1),\n\t        B = cartesianScale(n2, c2);\n\t    cartesianAddInPlace(A, B);\n\n\t    // Solve |p(t)|^2 = 1.\n\t    var u = n1xn2,\n\t        w = cartesianDot(A, u),\n\t        uu = cartesianDot(u, u),\n\t        t2 = w * w - uu * (cartesianDot(A, A) - 1);\n\n\t    if (t2 < 0) return;\n\n\t    var t = sqrt(t2),\n\t        q = cartesianScale(u, (-w - t) / uu);\n\t    cartesianAddInPlace(q, A);\n\t    q = spherical(q);\n\n\t    if (!two) return q;\n\n\t    // Two intersection points.\n\t    var lambda0 = a[0],\n\t        lambda1 = b[0],\n\t        phi0 = a[1],\n\t        phi1 = b[1],\n\t        z;\n\n\t    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;\n\n\t    var delta = lambda1 - lambda0,\n\t        polar = abs(delta - pi) < epsilon,\n\t        meridian = polar || delta < epsilon;\n\n\t    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;\n\n\t    // Check that the first point is between a and b.\n\t    if (meridian\n\t        ? polar\n\t          ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1)\n\t          : phi0 <= q[1] && q[1] <= phi1\n\t        : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {\n\t      var q1 = cartesianScale(u, (-w + t) / uu);\n\t      cartesianAddInPlace(q1, A);\n\t      return [q, spherical(q1)];\n\t    }\n\t  }\n\n\t  // Generates a 4-bit vector representing the location of a point relative to\n\t  // the small circle's bounding box.\n\t  function code(lambda, phi) {\n\t    var r = smallRadius ? radius : pi - radius,\n\t        code = 0;\n\t    if (lambda < -r) code |= 1; // left\n\t    else if (lambda > r) code |= 2; // right\n\t    if (phi < -r) code |= 4; // below\n\t    else if (phi > r) code |= 8; // above\n\t    return code;\n\t  }\n\n\t  return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);\n\t}\n\n\tfunction transformer(methods) {\n\t  return function(stream) {\n\t    var s = new TransformStream;\n\t    for (var key in methods) s[key] = methods[key];\n\t    s.stream = stream;\n\t    return s;\n\t  };\n\t}\n\n\tfunction TransformStream() {}\n\n\tTransformStream.prototype = {\n\t  constructor: TransformStream,\n\t  point: function(x, y) { this.stream.point(x, y); },\n\t  sphere: function() { this.stream.sphere(); },\n\t  lineStart: function() { this.stream.lineStart(); },\n\t  lineEnd: function() { this.stream.lineEnd(); },\n\t  polygonStart: function() { this.stream.polygonStart(); },\n\t  polygonEnd: function() { this.stream.polygonEnd(); }\n\t};\n\n\tfunction fitExtent(projection, extent, object) {\n\t  var w = extent[1][0] - extent[0][0],\n\t      h = extent[1][1] - extent[0][1],\n\t      clip = projection.clipExtent && projection.clipExtent();\n\n\t  projection\n\t      .scale(150)\n\t      .translate([0, 0]);\n\n\t  if (clip != null) projection.clipExtent(null);\n\n\t  geoStream(object, projection.stream(boundsStream$1));\n\n\t  var b = boundsStream$1.result(),\n\t      k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),\n\t      x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,\n\t      y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;\n\n\t  if (clip != null) projection.clipExtent(clip);\n\n\t  return projection\n\t      .scale(k * 150)\n\t      .translate([x, y]);\n\t}\n\n\tfunction fitSize(projection, size, object) {\n\t  return fitExtent(projection, [[0, 0], size], object);\n\t}\n\n\tvar maxDepth = 16;\n\tvar cosMinDistance = cos(30 * radians);\n\t// cos(minimum angular distance)\n\n\tfunction resample(project, delta2) {\n\t  return +delta2 ? resample$1(project, delta2) : resampleNone(project);\n\t}\n\n\tfunction resampleNone(project) {\n\t  return transformer({\n\t    point: function(x, y) {\n\t      x = project(x, y);\n\t      this.stream.point(x[0], x[1]);\n\t    }\n\t  });\n\t}\n\n\tfunction resample$1(project, delta2) {\n\n\t  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {\n\t    var dx = x1 - x0,\n\t        dy = y1 - y0,\n\t        d2 = dx * dx + dy * dy;\n\t    if (d2 > 4 * delta2 && depth--) {\n\t      var a = a0 + a1,\n\t          b = b0 + b1,\n\t          c = c0 + c1,\n\t          m = sqrt(a * a + b * b + c * c),\n\t          phi2 = asin(c /= m),\n\t          lambda2 = abs(abs(c) - 1) < epsilon || abs(lambda0 - lambda1) < epsilon ? (lambda0 + lambda1) / 2 : atan2(b, a),\n\t          p = project(lambda2, phi2),\n\t          x2 = p[0],\n\t          y2 = p[1],\n\t          dx2 = x2 - x0,\n\t          dy2 = y2 - y0,\n\t          dz = dy * dx2 - dx * dy2;\n\t      if (dz * dz / d2 > delta2 // perpendicular projected distance\n\t          || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end\n\t          || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance\n\t        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);\n\t        stream.point(x2, y2);\n\t        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);\n\t      }\n\t    }\n\t  }\n\t  return function(stream) {\n\t    var lambda00, x00, y00, a00, b00, c00, // first point\n\t        lambda0, x0, y0, a0, b0, c0; // previous point\n\n\t    var resampleStream = {\n\t      point: point,\n\t      lineStart: lineStart,\n\t      lineEnd: lineEnd,\n\t      polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },\n\t      polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }\n\t    };\n\n\t    function point(x, y) {\n\t      x = project(x, y);\n\t      stream.point(x[0], x[1]);\n\t    }\n\n\t    function lineStart() {\n\t      x0 = NaN;\n\t      resampleStream.point = linePoint;\n\t      stream.lineStart();\n\t    }\n\n\t    function linePoint(lambda, phi) {\n\t      var c = cartesian([lambda, phi]), p = project(lambda, phi);\n\t      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);\n\t      stream.point(x0, y0);\n\t    }\n\n\t    function lineEnd() {\n\t      resampleStream.point = point;\n\t      stream.lineEnd();\n\t    }\n\n\t    function ringStart() {\n\t      lineStart();\n\t      resampleStream.point = ringPoint;\n\t      resampleStream.lineEnd = ringEnd;\n\t    }\n\n\t    function ringPoint(lambda, phi) {\n\t      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;\n\t      resampleStream.point = linePoint;\n\t    }\n\n\t    function ringEnd() {\n\t      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);\n\t      resampleStream.lineEnd = lineEnd;\n\t      lineEnd();\n\t    }\n\n\t    return resampleStream;\n\t  };\n\t}\n\n\tvar transformRadians = transformer({\n\t  point: function(x, y) {\n\t    this.stream.point(x * radians, y * radians);\n\t  }\n\t});\n\n\tfunction projectionMutator(projectAt) {\n\t  var project,\n\t      k = 150, // scale\n\t      x = 480, y = 250, // translate\n\t      dx, dy, lambda = 0, phi = 0, // center\n\t      deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, projectRotate, // rotate\n\t      theta = null, preclip = clipAntimeridian, // clip angle\n\t      x0 = null, y0, x1, y1, postclip = identity$1, // clip extent\n\t      delta2 = 0.5, projectResample = resample(projectTransform, delta2), // precision\n\t      cache,\n\t      cacheStream;\n\n\t  function projection(point) {\n\t    point = projectRotate(point[0] * radians, point[1] * radians);\n\t    return [point[0] * k + dx, dy - point[1] * k];\n\t  }\n\n\t  function invert(point) {\n\t    point = projectRotate.invert((point[0] - dx) / k, (dy - point[1]) / k);\n\t    return point && [point[0] * degrees, point[1] * degrees];\n\t  }\n\n\t  function projectTransform(x, y) {\n\t    return x = project(x, y), [x[0] * k + dx, dy - x[1] * k];\n\t  }\n\n\t  projection.stream = function(stream) {\n\t    return cache && cacheStream === stream ? cache : cache = transformRadians(preclip(rotate, projectResample(postclip(cacheStream = stream))));\n\t  };\n\n\t  projection.clipAngle = function(_) {\n\t    return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians, 6 * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;\n\t  };\n\n\t  projection.clipExtent = function(_) {\n\t    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$1) : clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n\t  };\n\n\t  projection.scale = function(_) {\n\t    return arguments.length ? (k = +_, recenter()) : k;\n\t  };\n\n\t  projection.translate = function(_) {\n\t    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];\n\t  };\n\n\t  projection.center = function(_) {\n\t    return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];\n\t  };\n\n\t  projection.rotate = function(_) {\n\t    return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];\n\t  };\n\n\t  projection.precision = function(_) {\n\t    return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);\n\t  };\n\n\t  projection.fitExtent = function(extent, object) {\n\t    return fitExtent(projection, extent, object);\n\t  };\n\n\t  projection.fitSize = function(size, object) {\n\t    return fitSize(projection, size, object);\n\t  };\n\n\t  function recenter() {\n\t    projectRotate = compose(rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma), project);\n\t    var center = project(lambda, phi);\n\t    dx = x - center[0] * k;\n\t    dy = y + center[1] * k;\n\t    return reset();\n\t  }\n\n\t  function reset() {\n\t    cache = cacheStream = null;\n\t    return projection;\n\t  }\n\n\t  return function() {\n\t    project = projectAt.apply(this, arguments);\n\t    projection.invert = project.invert && invert;\n\t    return recenter();\n\t  };\n\t}\n\n\tfunction conicProjection(projectAt) {\n\t  var phi0 = 0,\n\t      phi1 = pi / 3,\n\t      m = projectionMutator(projectAt),\n\t      p = m(phi0, phi1);\n\n\t  p.parallels = function(_) {\n\t    return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees, phi1 * degrees];\n\t  };\n\n\t  return p;\n\t}\n\n\tfunction cylindricalEqualAreaRaw(phi0) {\n\t  var cosPhi0 = cos(phi0);\n\n\t  function forward(lambda, phi) {\n\t    return [lambda * cosPhi0, sin(phi) / cosPhi0];\n\t  }\n\n\t  forward.invert = function(x, y) {\n\t    return [x / cosPhi0, asin(y * cosPhi0)];\n\t  };\n\n\t  return forward;\n\t}\n\n\tfunction conicEqualAreaRaw(y0, y1) {\n\t  var sy0 = sin(y0), n = (sy0 + sin(y1)) / 2;\n\n\t  // Are the parallels symmetrical around the Equator?\n\t  if (abs(n) < epsilon) return cylindricalEqualAreaRaw(y0);\n\n\t  var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c) / n;\n\n\t  function project(x, y) {\n\t    var r = sqrt(c - 2 * n * sin(y)) / n;\n\t    return [r * sin(x *= n), r0 - r * cos(x)];\n\t  }\n\n\t  project.invert = function(x, y) {\n\t    var r0y = r0 - y;\n\t    return [atan2(x, abs(r0y)) / n * sign(r0y), asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];\n\t  };\n\n\t  return project;\n\t}\n\n\tfunction conicEqualArea() {\n\t  return conicProjection(conicEqualAreaRaw)\n\t      .scale(155.424)\n\t      .center([0, 33.6442]);\n\t}\n\n\tfunction albers() {\n\t  return conicEqualArea()\n\t      .parallels([29.5, 45.5])\n\t      .scale(1070)\n\t      .translate([480, 250])\n\t      .rotate([96, 0])\n\t      .center([-0.6, 38.7]);\n\t}\n\n\tfunction identity$3(x) {\n\t  return x;\n\t}\n\n\tfunction transform$1(transform) {\n\t  if (transform == null) return identity$3;\n\t  var x0,\n\t      y0,\n\t      kx = transform.scale[0],\n\t      ky = transform.scale[1],\n\t      dx = transform.translate[0],\n\t      dy = transform.translate[1];\n\t  return function(input, i) {\n\t    if (!i) x0 = y0 = 0;\n\t    var j = 2, n = input.length, output = new Array(n);\n\t    output[0] = (x0 += input[0]) * kx + dx;\n\t    output[1] = (y0 += input[1]) * ky + dy;\n\t    while (j < n) output[j] = input[j], ++j;\n\t    return output;\n\t  };\n\t}\n\n\tfunction reverse(array, n) {\n\t  var t, j = array.length, i = j - n;\n\t  while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;\n\t}\n\n\tfunction topoFeature(topology, o) {\n\t  return o.type === \"GeometryCollection\"\n\t      ? {type: \"FeatureCollection\", features: o.geometries.map(function(o) { return feature(topology, o); })}\n\t      : feature(topology, o);\n\t}\n\n\tfunction feature(topology, o) {\n\t  var id = o.id,\n\t      bbox = o.bbox,\n\t      properties = o.properties == null ? {} : o.properties,\n\t      geometry = object$1(topology, o);\n\t  return id == null && bbox == null ? {type: \"Feature\", properties: properties, geometry: geometry}\n\t      : bbox == null ? {type: \"Feature\", id: id, properties: properties, geometry: geometry}\n\t      : {type: \"Feature\", id: id, bbox: bbox, properties: properties, geometry: geometry};\n\t}\n\n\tfunction object$1(topology, o) {\n\t  var transformPoint = transform$1(topology.transform),\n\t      arcs = topology.arcs;\n\n\t  function arc(i, points) {\n\t    if (points.length) points.pop();\n\t    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {\n\t      points.push(transformPoint(a[k], k));\n\t    }\n\t    if (i < 0) reverse(points, n);\n\t  }\n\n\t  function point(p) {\n\t    return transformPoint(p);\n\t  }\n\n\t  function line(arcs) {\n\t    var points = [];\n\t    for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);\n\t    if (points.length < 2) points.push(points[0]); // This should never happen per the specification.\n\t    return points;\n\t  }\n\n\t  function ring(arcs) {\n\t    var points = line(arcs);\n\t    while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.\n\t    return points;\n\t  }\n\n\t  function polygon(arcs) {\n\t    return arcs.map(ring);\n\t  }\n\n\t  function geometry(o) {\n\t    var type = o.type, coordinates;\n\t    switch (type) {\n\t      case \"GeometryCollection\": return {type: type, geometries: o.geometries.map(geometry)};\n\t      case \"Point\": coordinates = point(o.coordinates); break;\n\t      case \"MultiPoint\": coordinates = o.coordinates.map(point); break;\n\t      case \"LineString\": coordinates = line(o.arcs); break;\n\t      case \"MultiLineString\": coordinates = o.arcs.map(line); break;\n\t      case \"Polygon\": coordinates = polygon(o.arcs); break;\n\t      case \"MultiPolygon\": coordinates = o.arcs.map(polygon); break;\n\t      default: return null;\n\t    }\n\t    return {type: type, coordinates: coordinates};\n\t  }\n\n\t  return geometry(o);\n\t}\n\n\tvar commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n\tfunction createCommonjsModule(fn, module) {\n\t\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n\t}\n\n\tvar index = createCommonjsModule(function (module, exports) {\n\t;(function (name, root, factory) {\n\t  if ('object' === 'object') {\n\t    module.exports = factory()\n\t  }\n\t  else {}\n\t}('dcopy', commonjsGlobal, function () {\n\t  /**\n\t   * Deep copy objects and arrays\n\t   *\n\t   * @param {Object/Array} target\n\t   * @return {Object/Array} copy\n\t   * @api public\n\t   */\n\n\t  return function (target) {\n\t    var copy = (target instanceof Array) ? [] : {}\n\t    ;(function read (target, copy) {\n\t      for (var key in target) {\n\t        var obj = target[key]\n\t        if (obj instanceof Array) {\n\t          var value = []\n\t          var last = add(copy, key, value)\n\t          read(obj, last)\n\t        }\n\t        else if (obj instanceof Object && typeof obj !== 'function') {\n\t          var value = {}\n\t          var last = add(copy, key, value)\n\t          read(obj, last)\n\t        }\n\t        else {\n\t          var value = obj\n\t          add(copy, key, value)\n\t        }\n\t      }\n\t    }(target, copy))\n\t    return copy\n\t  }\n\n\t  /**\n\t   * Adds a value to the copy object based on its type\n\t   *\n\t   * @api private\n\t   */\n\n\t  function add (copy, key, value) {\n\t    if (copy instanceof Array) {\n\t      copy.push(value)\n\t      return copy[copy.length - 1]\n\t    }\n\t    else if (copy instanceof Object) {\n\t      copy[key] = value\n\t      return copy[key]\n\t    }\n\t  }\n\t}))\n\t});\n\n\tfunction cartogram() {\n\t    /*\n\t     * d3.cartogram is a d3-friendly implementation of An Algorithm to Construct\n\t     * Continuous Area Cartograms:\n\t     *\n\t     * <http://lambert.nico.free.fr/tp/biblio/Dougeniketal1985.pdf>\n\t     *\n\t     * It requires topojson to decode TopoJSON-encoded topologies:\n\t     *\n\t     * <http://github.com/mbostock/topojson/>\n\t     *\n\t     * Usage:\n\t     * var proj = d3.geo.albersUsa(),\n\t     *     path = d3.geoPath()\n\t     *        .projection(proj);\n\t     * d3.geoPath()\n\t     *        .projection(proj);\n\t     * var cartogram = d3.cartogram()\n\t     *  .projection(proj)\n\t     *  .value(function(d) {\n\t     *    return Math.random() * 100;\n\t     *  });\n\t     * d3.json(\"path/to/topology.json\", function(topology) {\n\t     *  var features = cartogram.features(topology, topology.objects.OBJECTNAME.geometries);\n\t     *  d3.select(\"svg\").selectAll(\"path\")\n\t     *    .data(features)\n\t     *    .enter()\n\t     *    .append(\"path\")\n\t     *      .attr(\"d\", path);\n\t     * });\n\t     */\n\n\t   var iterations = 8,\n\t        projection = albers(),\n\t        properties = function(id) {\n\t            return {};\n\t        },\n\t        value = function(d) {\n\t            return 1;\n\t        };\n\n\t  function cartogram(topology, geometries) {\n\n\t    // copy it first\n\t    topology = copy(topology);\n\n\t    // objects are projected into screen coordinates\n\n\t    // project the arcs into screen space\n\t    var tf = transformer(topology.transform),x,y,len1,i1,out1,len2=topology.arcs.length,i2=0,\n\t        projectedArcs = new Array(len2);\n\t        while(i2<len2){\n\t          x = 0;\n\t          y = 0;\n\t          len1 = topology.arcs[i2].length;\n\t          i1 = 0;\n\t          out1 = new Array(len1);\n\t          while(i1<len1){\n\t            topology.arcs[i2][i1][0] = (x += topology.arcs[i2][i1][0]);\n\t            topology.arcs[i2][i1][1] = (y += topology.arcs[i2][i1][1]);\n\t            out1[i1] = projection === null ? tf(topology.arcs[i2][i1]) : projection(tf(topology.arcs[i2][i1]));\n\t            i1++;\n\t          }\n\t          projectedArcs[i2++]=out1;\n\t          \n\t        }\n\n\t    // path with identity projection\n\t    var path = geoPath()\n\t      .projection(null);\n\n\t    var objects = object(projectedArcs, {type: \"GeometryCollection\", geometries: geometries})\n\t        .geometries.map(function(geom) {\n\t          return {\n\t            type: \"Feature\",\n\t            id: geom.id,\n\t            properties: properties.call(null, geom, topology),\n\t            geometry: geom\n\t          };\n\t        });\n\n\t    var values = objects.map(value),\n\t        totalValue = sum(values);\n\n\t    // no iterations; just return the features\n\t    if (iterations <= 0) {\n\t      return objects;\n\t    }\n\n\t    var i = 0;\n\t    while (i++ < iterations) {\n\t      var areas = objects.map(path.area);\n\t          var totalArea = sum(areas),\n\t          sizeErrorsTot =0,\n\t          sizeErrorsNum=0,\n\t          meta = objects.map(function(o, j) {\n\t            var area = Math.abs(areas[j]), // XXX: why do we have negative areas?\n\t                v = +values[j],\n\t                desired = totalArea * v / totalValue,\n\t                radius = Math.sqrt(area / Math.PI),\n\t                mass = Math.sqrt(desired / Math.PI) - radius,\n\t                sizeError = Math.max(area, desired) / Math.min(area, desired);\n\t            sizeErrorsTot+=sizeError;\n\t            sizeErrorsNum++;\n\t            // console.log(o.id, \"@\", j, \"area:\", area, \"value:\", v, \"->\", desired, radius, mass, sizeError);\n\t            return {\n\t              id:         o.id,\n\t              area:       area,\n\t              centroid:   path.centroid(o),\n\t              value:      v,\n\t              desired:    desired,\n\t              radius:     radius,\n\t              mass:       mass,\n\t              sizeError:  sizeError\n\t            };\n\t          });\n\n\t      var sizeError = sizeErrorsTot/sizeErrorsNum,\n\t          forceReductionFactor = 1 / (1 + sizeError);\n\n\t      // console.log(\"meta:\", meta);\n\t      // console.log(\"  total area:\", totalArea);\n\t      // console.log(\"  force reduction factor:\", forceReductionFactor, \"mean error:\", sizeError);\n\n\t      var len1,i1,delta,len2=projectedArcs.length,i2=0,delta,len3,i3,centroid,mass,radius,rSquared,dx,dy,distSquared,dist,Fij;\n\t      while(i2<len2){\n\t          len1=projectedArcs[i2].length;\n\t          i1=0;\n\t          while(i1<len1){\n\t            // create an array of vectors: [x, y]\n\t            delta = [0,0];\n\t            len3 = meta.length;\n\t            i3=0;\n\t            while(i3<len3) {\n\t              centroid =  meta[i3].centroid;\n\t              mass =      meta[i3].mass;\n\t              radius =    meta[i3].radius;\n\t              rSquared = (radius*radius);\n\t              dx = projectedArcs[i2][i1][0] - centroid[0];\n\t              dy = projectedArcs[i2][i1][1] - centroid[1];\n\t              distSquared = dx * dx + dy * dy;\n\t              dist=Math.sqrt(distSquared);\n\t              Fij = (dist > radius)\n\t                ? mass * radius / dist\n\t                : mass *\n\t                  (distSquared / rSquared) *\n\t                  (4 - 3 * dist / radius);\n\t              delta[0]+=(Fij * cosArctan(dy,dx));\n\t              delta[1]+=(Fij * sinArctan(dy,dx));\n\t              i3++;\n\t            }\n\t          projectedArcs[i2][i1][0] += (delta[0]*forceReductionFactor);\n\t          projectedArcs[i2][i1][1] += (delta[1]*forceReductionFactor);\n\t          i1++;\n\t        }\n\t        i2++;\n\t      }\n\n\t      // break if we hit the target size error\n\t      if (sizeError <= 1) break;\n\t    }\n\n\t    return {\n\t      features: objects,\n\t      arcs: projectedArcs\n\t    };\n\t  }      \n\n\t  function cosArctan(dx,dy) {\n\t    if (dy===0) return 0;\n\t    var div = dx/dy;\n\t    return (dy>0)?\n\t      (1/Math.sqrt(1+(div*div))):\n\t      (-1/Math.sqrt(1+(div*div)));\n\t  }\n\n\t  function sinArctan(dx,dy){\n\t    if (dy===0) return 1;\n\t    var div = dx/dy;\n\t    return (dy>0)?\n\t      (div/Math.sqrt(1+(div*div))):\n\t      (-div/Math.sqrt(1+(div*div)));\n\t  }\n\n\t  function copy(o) {\n\t    return (o instanceof Array)\n\t      ? o.map(copy)\n\t      : (typeof o === \"string\" || typeof o === \"number\")\n\t        ? o\n\t        : copyObject(o);\n\t  }\n\t    \n\t  function copyObject(o) {\n\t    var obj = {};\n\t    for (var k in o) obj[k] = copy(o[k]);\n\t    return obj;\n\t  }\n\n\t  function object(arcs, o) {\n\t    function arc(i, points) {\n\t      if (points.length) points.pop();\n\t      for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {\n\t        points.push(a[k]);\n\t      }\n\t      if (i < 0) reverse(points, n);\n\t    }\n\n\t    function line(arcs) {\n\t      var points = [];\n\t      for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);\n\t      return points;\n\t    }\n\n\t    function polygon(arcs) {\n\t      return arcs.map(line);\n\t    }\n\n\t    function geometry(o) {\n\t      o = Object.create(o);\n\t      o.coordinates = geometryType[o.type](o.arcs);\n\t      return o;\n\t    }\n\n\t    var geometryType = {\n\t        LineString: line,\n\t        MultiLineString: polygon,\n\t        Polygon: polygon,\n\t        MultiPolygon: function(arcs) { return arcs.map(polygon); }\n\t    };\n\n\t    return o.type === \"GeometryCollection\"\n\t          ? (o = Object.create(o), o.geometries = o.geometries.map(geometry), o)\n\t          : geometry(o);\n\t  }\n\n\t  function reverse(array, n) {\n\t      var t, j = array.length, i = j - n; while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;\n\t  }\n\n\t     // for convenience\n\t  cartogram.path = geoPath()\n\t        .projection(null);\n\n\t  cartogram.iterations = function(i) {\n\t        if (arguments.length) {\n\t          iterations = i;\n\t          return cartogram;\n\t        } else {\n\t          return iterations;\n\t        }\n\t      };\n\n\t  cartogram.value = function(v) {\n\t        if (arguments.length) {\n\t          value = typeof v === \"function\" ? v : constant(v);\n\t          return cartogram;\n\t        } else {\n\t          return value;\n\t        }\n\t      };\n\n\t  cartogram.projection = function(p) {\n\t        if (arguments.length) {\n\t          projection = p;\n\t          return cartogram;\n\t        } else {\n\t          return projection;\n\t        }\n\t      };\n\n\t  cartogram.feature = function(topology, geom) {\n\t        return {\n\t          type: \"Feature\",\n\t          id: geom.id,\n\t          properties: properties.call(null, geom, topology),\n\t          geometry: {\n\t            type: geom.type,\n\t            coordinates: topoFeature(topology, geom).geometry.coordinates\n\t          }\n\t        };\n\t      };\n\n\t  cartogram.features = function(topo, geometries) {\n\t    return geometries.map(function(f) {\n\t      return cartogram.feature(topo, f);\n\t    });\n\t  };\n\n\t  cartogram.properties = function(props) {\n\t    if (arguments.length) {\n\t      properties = typeof props === \"function\" ? props : constant(props);\n\t      return cartogram;\n\t    } else {\n\t      return properties;\n\t    }\n\t  };\n\n\t  function constant(x) {\n\t    return function() {\n\t      return x;\n\t    };\n\t  };\n\n\n\t  var transformer = cartogram.transformer = function(tf) {\n\t      var kx = tf.scale[0],\n\t          ky = tf.scale[1],\n\t          dx = tf.translate[0],\n\t          dy = tf.translate[1];\n\n\t      function transform(c) {\n\t        return [c[0] * kx + dx, c[1] * ky + dy];\n\t      }\n\n\t      transform.invert = function(c) {\n\t        return [(c[0] - dx) / kx, (c[1]- dy) / ky];\n\t      };\n\n\t      return transform;\n\t    };\n\n\t  return cartogram;\n\t};\n\n\texports.cartogram = cartogram;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n}));","import { hexbin } from 'd3-hexbin'\nimport * as topogram from \"topogram\";\nimport { scaleLinear } from 'd3-scale'\n\ndocument.querySelector('#loader').classList.add(\"hide\");\nlet colors = ['#1abc9c', '#2ecc71', '#3498db', '#9b59b6', '#34495e', '#16a085', '#27ae60', '#2980b9', '#8e44ad', '#2c3e50',\n  '#f1c40f', '#e67e22', '#e74c3c', '#ecf0f1', '#95a5a6', '#f39c12', '#d35400', '#c0392b', '#bdc3c7', '#7f8c8d']\n\nlet radiusInput = document.querySelector('input#radius');\nlet radiusButton = document.querySelector('input#select-radius');\n\nlet downloadButton = document.querySelector('#download');\n\nlet yearInput = document.querySelector('input#year');\nlet yearButton = document.querySelector('input#select-year');\n\nradiusButton.addEventListener('click', () => {\n  radiusInput = document.querySelector('input#radius');\n  document.querySelector('#loader').classList.remove(\"hide\");\n  start()\n});\n\nyearButton.addEventListener('click', () => {\n  yearInput = document.querySelector('input#year');\n  document.querySelector('#loader').classList.remove(\"hide\");\n  start()\n});\n\ndownloadButton.addEventListener('mouseover', () => {\n  console.log(\"test\")\n  d3.select(\"#download\").on(\"click\", function () {\n    d3.select(this)\n      .attr(\"href\", 'data:application/octet-stream;base64,' + btoa(d3.select(\"#container\").html()))\n      .attr(\"download\", \"cartogram.svg\")\n  })\n});\n\nconst margin = { top: 15, right: 10, bottom: 15, left: 10 };\nconst width = 1350 - margin.left - margin.right;\nconst height = 750 - margin.top - margin.bottom;\nconst strokeWidth = 0.5\n\nfunction start() {\n  let hexRadius = radiusInput.value\n  const topoData = d3.json('https://raw.githubusercontent.com/addu390/population-cartogram/master/data/population/2018/v2/topo.json');\n  const popData = d3.csv('https://raw.githubusercontent.com/addu390/population-cartogram/master/data/world-population-unpd-flat.csv');\n  Promise.all([topoData, popData]).then(res => {\n    let [topoData, popData] = res;\n\n    plot_map(topoData, popData, hexRadius, true);\n    document.querySelector('#loader').classList.add(\"hide\");\n  });\n}\n\nfunction plot_map(topo, pop, hexRadius, isProjected) {\n  let hexDistance = hexRadius * 1.5\n  let cols = width / hexDistance\n  let rows = Math.ceil(height / hexDistance);\n  let pointGrid = d3.range(rows * cols).map(function (el, i) {\n    return {\n      x: Math.floor(i % cols) * hexDistance,\n      y: Math.floor(i / cols) * hexDistance,\n      datapoint: 0\n    };\n  });\n\n  var populationJson = getData(pop)\n\n  var cartogram = topogram.cartogram()\n    .projection(null)\n    .properties(function (d) {\n      return d.properties;\n    })\n    .value(function (d) {\n      var currentValue = d.properties.count\n      return +currentValue\n    });\n\n  cartogram.features(topo, topo.objects.tiles.geometries)\n\n  var scale = d3.scaleLinear()\n    .domain([1, 1000000000])\n    .range([1, 1000]);\n\n  cartogram.value(function (d) {\n    var currentValue = populationJson[d.properties.id][yearInput.value]\n    return +currentValue\n  });\n\n  var topoFeatures = cartogram(topo, topo.objects.tiles.geometries).features\n\n  let features = []\n  for (let i = 0; i < topoFeatures.length; i++) {\n    var tempFeatures = []\n    if (topoFeatures[i].geometry.type == \"MultiPolygon\") {\n      for (let j = 0; j < topoFeatures[i].geometry.coordinates.length; j++) {\n        tempFeatures[j] = topoFeatures[i].geometry.coordinates[j][0]\n      }\n    }\n    else if (topoFeatures[i].geometry.type == \"Polygon\") {\n      tempFeatures[0] = topoFeatures[i].geometry.coordinates[0]\n    }\n    features[i] = {\n      \"coordinates\": tempFeatures,\n      \"properties\": topoFeatures[i].properties\n    }\n  }\n\n  d3.select('#container').selectAll(\"*\").remove()\n\n  let newHexbin = hexbin()\n    .radius(hexRadius)\n    .x(function (d) { return d.x; })\n    .y(function (d) { return d.y; })\n\n  const svg = d3.select('#container')\n    .append('svg')\n    .attr('width', width + margin.left + margin.top)\n    .attr('height', height + margin.top + margin.bottom)\n    .append('g')\n    .attr('transform', `translate(${margin.left} ${margin.top})`);\n\n  svg.append('g').attr('id', 'hexes')\n    .selectAll('.hex')\n    .data(newHexbin(pointGrid))\n    .enter().append('path')\n    .attr('class', 'hex')\n    .attr('transform', function (d) { return 'translate(' + d.x + ', ' + d.y + ')'; })\n    .attr('d', newHexbin.hexagon())\n    .style('fill', '#fff')\n    .style('stroke', '#e0e0e0')\n    .style('stroke-width', strokeWidth)\n    .on(\"click\", mclickBase);\n\n  for (let i = 0; i < features.length; i++) {\n    for (let j = 0; j < features[i].coordinates.length; j++) {\n      var polygonPoints = features[i].coordinates[j];\n\n      let usPoints = pointGrid.reduce(function (arr, el) {\n        if (d3.polygonContains(polygonPoints, [el.x, el.y])) arr.push(el);\n        return arr;\n      }, [])\n\n      let hexPoints = newHexbin(usPoints)\n\n      svg.append('g')\n        .attr('id', 'hexes')\n        .selectAll('.hex')\n        .data(hexPoints)\n        .enter().append('path')\n        .attr('class', 'hex' + features[i].properties.id)\n        .attr('transform', function (d) { return 'translate(' + d.x + ', ' + d.y + ')'; })\n        .attr(\"x\", function (d) { return d.x; })\n        .attr(\"y\", function (d) { return d.y; })\n        .attr('d', newHexbin.hexagon())\n        .style('fill', colors[i % 19])\n        .style('stroke', '#000')\n        .style('stroke-width', strokeWidth)\n        .on(\"click\", mclick)\n        .on(\"mouseover\", mover)\n        .on(\"mouseout\", mout)\n        .call(d3.drag()\n          .on(\"start\", dragstarted)\n          .on(\"drag\", dragged)\n          .on(\"end\", dragended));\n    }\n  }\n}\n\nfunction mover(d) {\n  d3.select(this)\n    .transition()\n    .duration(10)\n    .style(\"fill-opacity\", 0.9);\n}\n\nfunction mclickBase(d) {\n  let selectElement = document.querySelector('#label-option');\n  if (selectElement.value == \"Remove\") {\n    d3.select(this)\n      .style('fill', '#fff')\n      .style('stroke', '#e0e0e0')\n      .style('stroke-width', strokeWidth)\n      .lower();\n  } else {\n    let colorElement = document.querySelector('#color-option');\n    d3.select(this)\n      .style('stroke-width', strokeWidth)\n      .style('fill', colorElement.value)\n      .style('stroke', '#000')\n      .on(\"mouseover\", mover)\n      .on(\"mouseout\", mout)\n      .call(d3.drag()\n        .on(\"start\", dragstarted)\n        .on(\"drag\", dragged)\n        .on(\"end\", dragended))\n      .raise();\n  }\n}\n\nfunction mclick(d) {\n  let selectElement = document.querySelector('#label-option');\n  if (selectElement.value == \"Remove\") {\n    d3.select(this)\n      .remove()\n  } else {\n    let colorElement = document.querySelector('#color-option');\n    d3.select(this)\n      .style('stroke-width', strokeWidth)\n      .style('fill', colorElement.value)\n      .style('stroke', '#000')\n      .on(\"mouseover\", mover)\n      .on(\"mouseout\", mout)\n      .call(d3.drag()\n        .on(\"start\", dragstarted)\n        .on(\"drag\", dragged)\n        .on(\"end\", dragended))\n      .raise();\n  }\n}\n\nfunction mout(d) {\n  d3.select(this)\n    .transition()\n    .duration(10)\n    .style(\"fill-opacity\", 1);\n}\n\nfunction dragstarted(event, d) {\n  d.fixed = false\n  d3.select(this).raise()\n    .style('stroke-width', 1)\n    .style('stroke', '#000');\n}\n\nfunction dragged(event, d) {\n  let hexRadius = radiusInput.value\n  var x = event.x\n  var y = event.y\n  var grids = round(x, y, hexRadius);\n  d3.select(this)\n    .attr(\"x\", d.x = grids[0])\n    .attr(\"y\", d.y = grids[1])\n    .attr('transform', function (d) { return 'translate(' + d.x + ', ' + d.y + ')'; })\n}\n\nfunction dragended(event, d) {\n  d.fixed = true\n  d3.select(this)\n    .style('stroke-width', strokeWidth)\n    .style('stroke', '#000');\n}\n\nfunction round(x, y, n) {\n  var gridx\n  var gridy\n  var factor = Math.sqrt(3) / 2\n  var d = n * 2\n  var sx = d * factor\n  var sy = n * 3\n  if (y % sy < n) {\n    gridy = y - (y % sy)\n    gridx = x - (x % sx)\n  } else {\n    gridy = y + (d - (n * factor) / 2) - (y % sy);\n    gridx = x + (n * factor) - (x % sx);\n  }\n  return [gridx, gridy]\n}\n\nfunction getData(data) {\n  var obj = {}\n  for (var x in data) {\n    obj[data[x].code] = data[x]\n  }\n  return obj\n}\n\nstart()"],"names":["$28bd4c13f05a9ff5$var$thirdPi","Math","PI","$28bd4c13f05a9ff5$var$angles","$28bd4c13f05a9ff5$var$pointX","d","$28bd4c13f05a9ff5$var$pointY","exports","ascending","a","b","NaN","bisector","compare","length","ascendingComparator","left","x","lo","hi","mid","right","f","merge","arrays","m","merged","array","n","i","j","Array","sum","s","adder1","Adder","this","reset","prototype","constructor","t","add","y","add1","temp","valueOf","adder","bv","av","epsilon","pi","halfPi","quarterPi","tau","degrees","radians","abs","atan","atan2","cos","sin","sign1","sign","sqrt","acos","asin","noop","streamGeometry","geometry","stream","streamGeometryType","hasOwnProperty","type","streamObjectType","Feature","object","FeatureCollection","features","Sphere","sphere","Point","coordinates","point","MultiPoint","LineString","streamLine","MultiLineString","Polygon","streamPolygon","MultiPolygon","GeometryCollection","geometries","closed","coordinate","lineStart","lineEnd","polygonStart","polygonEnd","geoStream","spherical1","cartesian","cartesian1","spherical","lambda","phi","cosPhi","cartesianDot","cartesianCross","cartesianAddInPlace","cartesianScale","vector","k","cartesianNormalizeInPlace","l","compose1","compose","invert","rotationIdentity","rotateRadians","deltaLambda","deltaPhi","deltaGamma","rotationLambda","rotationPhiGamma","forwardRotationLambda","rotation","cosDeltaPhi","sinDeltaPhi","cosDeltaGamma","sinDeltaGamma","z","circleStream","radius","delta","direction","t0","t1","cosRadius","sinRadius","step","circleRadius","clipBuffer","line","lines","push","rejoin","pop","concat","shift","result","clipLine1","x0","y0","x1","y1","r","ax","ay","dx","dy","pointEqual","Intersection","points","other","entry","o","e","v","p","clipPolygon","segments","compareIntersection","startInside","interpolate","n1","subject","clip","forEach","segment","p0","p1","sort","link","start","current","isSubject","clipMax","clipMin","clipExtent","visible1","from","to","a1","corner","comparePoint","ca","cb","polygon","ring1","x__","y__","v__","x_","y_","v_","first","clean","activeStream","bufferStream","clipStream","point1","polygonInside","winding","a0","ring","b0","b1","cleanInside","visible","linePoint","max","min","sum$1","polygonContains","normal","angle","point0","lambda0","phi0","sinPhi0","cosPhi0","lambda1","sinPhi1","cosPhi1","phi1","absDelta","antimeridian","arc","intersection","phiArc","identity$1","x001","y001","x0$1","y0$1","areaSum$1","areaRingSum$1","areaStream$1","areaRingStart$1","areaRingEnd$1","area","areaPointFirst$1","areaPoint$1","x0$2","Infinity","y0$2","x11","y11","boundsStream$1","boundsPoint$1","bounds","x00$1","y00$1","x0$3","y0$3","X0$1","Y0$1","Z0$1","X1$1","Y1$1","Z1$1","X2$1","Y2$1","Z2$1","centroidStream$1","centroidPoint$1","centroidLineStart$1","centroidLineEnd$1","centroidRingStart$1","centroidRingEnd$1","centroid","centroidPointFirstLine","centroidPointLine","centroidPointFirstRing","centroidPointRing","PathContext","context","_context","_radius","pointRadius","_","_line","_point","closePath","moveTo","lineTo","lengthRing","x00$2","y00$2","x0$4","y0$4","lengthSum$1","lengthStream$1","lengthPointFirst$1","lengthPoint$1","PathString","_string","circle$1","geoPath","projection","projectionStream","contextStream","path","apply","arguments","measure","clip1","pointVisible","clipLine","rotate","sink","rotatedStart","ringBuffer","ringSink","polygonStarted","point2","pointRing","ringStart","ringEnd","compareIntersection1","pointLine","ringSegments","filter","validSegment","_circle","join","clipAntimeridian","clipAntimeridianLine","clipAntimeridianInterpolate","sign0","clipAntimeridianIntersect","sinLambda0Lambda1","clipCircle","delta1","cr","smallRadius","notHemisphere","c0","v0","v00","c","code1","intersect","two","n2","n2n2","n1n2","determinant","c1","c2","n1xn2","A","u","w","uu","t2","q","polar","q1","code","transformer1","methods","TransformStream","key","fitExtent","extent","h","scale","translate","fitSize","size","maxDepth","cosMinDistance","resample","project","delta2","resample$1","resampleNone","resampleLineTo","depth","d2","phi2","lambda2","x2","y2","dx2","dy2","dz","lambda00","x00","y00","a00","b00","c00","resampleStream","ringPoint","transformRadians","projectionMutator","projectAt","projectRotate","cache","cacheStream","x3","y3","theta","preclip","postclip","projectResample","projectTransform","recenter","center","clipAngle","precision","conicProjection","parallels","cylindricalEqualAreaRaw","forward","conicEqualAreaRaw","sy0","r0","r0y","conicEqualArea","albers","identity$3","transform$1","transform","kx","ky","input","output","reverse1","topoFeature","topology","o1","map","feature","id","bbox","properties","object$1","o2","transformPoint","arcs1","arcs","createCommonjsModule","fn","module","cartogram1","iterations","value","cartogram","copy","out1","tf","transformer","len2","i2","projectedArcs","len1","i1","objects","geom","call","values","totalValue","len3","i3","mass1","radius1","rSquared","distSquared","dist","Fij","areas","totalArea","sizeErrorsTot","sizeErrorsNum","meta","desired","mass","sizeError","sizeError1","forceReductionFactor","cosArctan","sinArctan","div","copyObject","obj","arcs2","o3","reverse","Object","create","geometryType","constant","topo","props","window","$parcel$global","self","name","root","factory","commonjsGlobal","target1","copy1","read","target","defineProperty","$9ba214e206398840$exports","document","querySelector","classList","$6b17f08f738443dc$var$colors","$6b17f08f738443dc$var$radiusInput","$6b17f08f738443dc$var$radiusButton","$6b17f08f738443dc$var$downloadButton","$6b17f08f738443dc$var$yearInput","$6b17f08f738443dc$var$yearButton","addEventListener","remove","$6b17f08f738443dc$var$start","console","log","d3","select","on","attr","btoa","html","$6b17f08f738443dc$var$margin","$6b17f08f738443dc$var$width","$6b17f08f738443dc$var$height","hexRadius","topoData1","json","popData1","csv","Promise","all","then","res","topoData","popData","isProjected","hexDistance","cols","rows","ceil","pointGrid","range","el","floor","datapoint","populationJson","data","$6b17f08f738443dc$var$getData","count","tiles","scaleLinear","domain","topoFeatures","tempFeatures","selectAll","newHexbin","dx1","dy1","x01","y01","hexbin","binsById","bins","isNaN","px","py","pj","round","py1","px1","pi2","pj2","px2","py2","bin","hexagon","centers","mesh","fragment","slice","$28bd4c13f05a9ff5$export$2e2bcd8739ae039","svg","append","enter","style","$6b17f08f738443dc$var$mclickBase","polygonPoints","hexPoints","reduce","arr","$6b17f08f738443dc$var$mclick","$6b17f08f738443dc$var$mover","$6b17f08f738443dc$var$mout","drag","$6b17f08f738443dc$var$dragstarted","$6b17f08f738443dc$var$dragged","$6b17f08f738443dc$var$dragended","$6b17f08f738443dc$var$plot_map","transition","duration","lower","colorElement","raise","event","fixed","d1","grids","gridx","gridy","factor","sx","sy","$6b17f08f738443dc$var$round"],"version":3,"file":"index.61a28894.js.map"}